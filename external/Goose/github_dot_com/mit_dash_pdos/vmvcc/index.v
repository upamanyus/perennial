(* autogenerated from github.com/mit-pdos/vmvcc/index *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.vmvcc.config.
From Goose Require github_dot_com.mit_dash_pdos.vmvcc.tuple.
From Goose Require sync.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition IndexBucket := struct.decl [
  "latch" :: ptrT;
  "m" :: mapT ptrT
].

Definition Index := struct.decl [
  "buckets" :: slice.T ptrT
].

Definition MkIndex: val :=
  rec: "MkIndex" <> :=
    let: "idx" := struct.alloc Index (zero_val (struct.t Index)) in
    struct.storeF Index "buckets" "idx" (NewSlice ptrT config.N_IDX_BUCKET);;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < config.N_IDX_BUCKET); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "b" := struct.alloc IndexBucket (zero_val (struct.t IndexBucket)) in
      struct.storeF IndexBucket "latch" "b" (struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)));;
      struct.storeF IndexBucket "m" "b" (NewMap uint64T ptrT #());;
      SliceSet ptrT (struct.loadF Index "buckets" "idx") (![uint64T] "i") "b";;
      Continue);;
    "idx".

Definition getBucket: val :=
  rec: "getBucket" "key" :=
    (("key" ≫ #52) + "key") `rem` config.N_IDX_BUCKET.

(* @GetTuple returns the tuple pointer associated with the key.

   @GetTuple will always create a tuple when there is no entry in @m. This
   design choice seems to wasteful as it will allocate a tuple even with an
   empty @txn.Get, but is actually a must: A @txn.Get should prevent earlier
   txns from creating new versions, even when it fails to retrieve a value. *)
Definition Index__GetTuple: val :=
  rec: "Index__GetTuple" "idx" "key" :=
    let: "b" := getBucket "key" in
    let: "bucket" := SliceGet ptrT (struct.loadF Index "buckets" "idx") "b" in
    sync.Mutex__Lock (struct.loadF IndexBucket "latch" "bucket");;
    let: ("tupleCur", "ok") := MapGet (struct.loadF IndexBucket "m" "bucket") "key" in
    (if: "ok"
    then
      sync.Mutex__Unlock (struct.loadF IndexBucket "latch" "bucket");;
      "tupleCur"
    else
      let: "tupleNew" := tuple.MkTuple #() in
      MapInsert (struct.loadF IndexBucket "m" "bucket") "key" "tupleNew";;
      sync.Mutex__Unlock (struct.loadF IndexBucket "latch" "bucket");;
      "tupleNew").

(* @getKeys returns keys in the index. Note that the return key set is merely an
   under-approximation of the actual key set. *)
Definition Index__getKeys: val :=
  rec: "Index__getKeys" "idx" :=
    let: "keys" := ref (zero_val (slice.T uint64T)) in
    "keys" <-[slice.T uint64T] (NewSliceWithCap uint64T #0 #200);;
    ForSlice ptrT <> "bkt" (struct.loadF Index "buckets" "idx")
      (sync.Mutex__Lock (struct.loadF IndexBucket "latch" "bkt");;
      MapIter (struct.loadF IndexBucket "m" "bkt") (λ: "k" <>,
        "keys" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "keys") "k"));;
      sync.Mutex__Unlock (struct.loadF IndexBucket "latch" "bkt"));;
    ![slice.T uint64T] "keys".

(* TODO: move this out to a separate GC module. *)
Definition Index__DoGC: val :=
  rec: "Index__DoGC" "idx" "tidMin" :=
    let: "keys" := Index__getKeys "idx" in
    ForSlice uint64T <> "k" "keys"
      (let: "tuple" := Index__GetTuple "idx" "k" in
      tuple.Tuple__RemoveVersions "tuple" "tidMin");;
    #().

End code.
