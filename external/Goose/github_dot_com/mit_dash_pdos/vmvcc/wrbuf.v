(* autogenerated from github.com/mit-pdos/vmvcc/wrbuf *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.vmvcc.common.
From Goose Require github_dot_com.mit_dash_pdos.vmvcc.index.
From Goose Require github_dot_com.mit_dash_pdos.vmvcc.tuple.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

(* @key and @val
   Key-value pair of the write entry.

   @wr
   Write @key with @val, or delete @key.

   @tpl
   Tuple pointer. Exists to save one index-lookup per write entry--written by
   @OpenTuples and read by @UpdateTuples. *)
Definition WrEnt := struct.decl [
  "key" :: uint64T;
  "val" :: stringT;
  "wr" :: boolT;
  "tpl" :: ptrT
].

(* Linear search can be quite slow when there are many entries. *)
Definition search: val :=
  rec: "search" "ents" "key" :=
    let: "pos" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, ((![uint64T] "pos") < (slice.len "ents")) && ("key" ≠ (struct.get WrEnt "key" (SliceGet (struct.t WrEnt) "ents" (![uint64T] "pos"))))); (λ: <>, Skip) := λ: <>,
      "pos" <-[uint64T] ((![uint64T] "pos") + #1);;
      Continue);;
    let: "found" := (![uint64T] "pos") < (slice.len "ents") in
    (![uint64T] "pos", "found").

Definition swap: val :=
  rec: "swap" "ents" "i" "j" :=
    let: "tmp" := SliceGet (struct.t WrEnt) "ents" "i" in
    SliceSet (struct.t WrEnt) "ents" "i" (SliceGet (struct.t WrEnt) "ents" "j");;
    SliceSet (struct.t WrEnt) "ents" "j" "tmp";;
    #().

Definition WrBuf := struct.decl [
  "ents" :: slice.T (struct.t WrEnt)
].

Definition MkWrBuf: val :=
  rec: "MkWrBuf" <> :=
    let: "wrbuf" := struct.alloc WrBuf (zero_val (struct.t WrBuf)) in
    struct.storeF WrBuf "ents" "wrbuf" (NewSliceWithCap (struct.t WrEnt) #0 #16);;
    "wrbuf".

Definition WrBuf__sortEntsByKey: val :=
  rec: "WrBuf__sortEntsByKey" "wrbuf" :=
    let: "ents" := struct.loadF WrBuf "ents" "wrbuf" in
    let: "i" := ref_to uint64T #1 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (slice.len "ents")); (λ: <>, Skip) := λ: <>,
      let: "j" := ref_to uint64T (![uint64T] "i") in
      Skip;;
      (for: (λ: <>, (![uint64T] "j") > #0); (λ: <>, Skip) := λ: <>,
        (if: (struct.get WrEnt "key" (SliceGet (struct.t WrEnt) "ents" ((![uint64T] "j") - #1))) ≤ (struct.get WrEnt "key" (SliceGet (struct.t WrEnt) "ents" (![uint64T] "j")))
        then Break
        else
          swap "ents" ((![uint64T] "j") - #1) (![uint64T] "j");;
          "j" <-[uint64T] ((![uint64T] "j") - #1);;
          Continue));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    #().

Definition WrBuf__Lookup: val :=
  rec: "WrBuf__Lookup" "wrbuf" "key" :=
    let: ("pos", "found") := search (struct.loadF WrBuf "ents" "wrbuf") "key" in
    (if: "found"
    then
      let: "ent" := SliceGet (struct.t WrEnt) (struct.loadF WrBuf "ents" "wrbuf") "pos" in
      (struct.get WrEnt "val" "ent", struct.get WrEnt "wr" "ent", #true)
    else (#(str""), #false, #false)).

Definition WrBuf__Put: val :=
  rec: "WrBuf__Put" "wrbuf" "key" "val" :=
    let: ("pos", "found") := search (struct.loadF WrBuf "ents" "wrbuf") "key" in
    (if: "found"
    then
      let: "ent" := SliceRef (struct.t WrEnt) (struct.loadF WrBuf "ents" "wrbuf") "pos" in
      struct.storeF WrEnt "val" "ent" "val";;
      struct.storeF WrEnt "wr" "ent" #true;;
      #()
    else
      let: "ent" := struct.mk WrEnt [
        "key" ::= "key";
        "val" ::= "val";
        "wr" ::= #true
      ] in
      struct.storeF WrBuf "ents" "wrbuf" (SliceAppend (struct.t WrEnt) (struct.loadF WrBuf "ents" "wrbuf") "ent");;
      #()).

Definition WrBuf__Delete: val :=
  rec: "WrBuf__Delete" "wrbuf" "key" :=
    let: ("pos", "found") := search (struct.loadF WrBuf "ents" "wrbuf") "key" in
    (if: "found"
    then
      let: "ent" := SliceRef (struct.t WrEnt) (struct.loadF WrBuf "ents" "wrbuf") "pos" in
      struct.storeF WrEnt "wr" "ent" #false;;
      #()
    else
      let: "ent" := struct.mk WrEnt [
        "key" ::= "key";
        "wr" ::= #false
      ] in
      struct.storeF WrBuf "ents" "wrbuf" (SliceAppend (struct.t WrEnt) (struct.loadF WrBuf "ents" "wrbuf") "ent");;
      #()).

(* @OpenTuples acquires the write locks of tuples to be updated by calling
   @tuple.Own.

   This design prevents deadlocks that show up in the design where transactions
   acquire write locks on writes. For instance, consider the following
   scenarios:

   Txn A | W(x)    R(y)
   Txn B |     W(y)    R(x)

   This causes a deadlock because A's R(y) waits on B's W(y), and B's R(x) waits
   on A's W(x). Acquring write locks at commit time breaks the wait-cycle since
   if one transaction waits on another, this means the latter must have entered
   the commit phase, and therefore never waits on anything. *)
Definition WrBuf__OpenTuples: val :=
  rec: "WrBuf__OpenTuples" "wrbuf" "tid" "idx" :=
    WrBuf__sortEntsByKey "wrbuf";;
    let: "ents" := struct.loadF WrBuf "ents" "wrbuf" in
    let: "pos" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "pos") < (slice.len "ents")); (λ: <>, Skip) := λ: <>,
      let: "ent" := SliceGet (struct.t WrEnt) "ents" (![uint64T] "pos") in
      let: "tpl" := index.Index__GetTuple "idx" (struct.get WrEnt "key" "ent") in
      let: "ret" := tuple.Tuple__Own "tpl" "tid" in
      (if: "ret" ≠ common.RET_SUCCESS
      then Break
      else
        SliceSet (struct.t WrEnt) "ents" (![uint64T] "pos") (struct.mk WrEnt [
          "key" ::= struct.get WrEnt "key" "ent";
          "val" ::= struct.get WrEnt "val" "ent";
          "wr" ::= struct.get WrEnt "wr" "ent";
          "tpl" ::= "tpl"
        ]);;
        "pos" <-[uint64T] ((![uint64T] "pos") + #1);;
        Continue));;
    (if: (![uint64T] "pos") < (slice.len "ents")
    then
      let: "i" := ref_to uint64T #0 in
      Skip;;
      (for: (λ: <>, (![uint64T] "i") < (![uint64T] "pos")); (λ: <>, Skip) := λ: <>,
        let: "tpl" := struct.get WrEnt "tpl" (SliceGet (struct.t WrEnt) "ents" (![uint64T] "i")) in
        tuple.Tuple__Free "tpl";;
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Continue);;
      #false
    else
      ForSlice (struct.t WrEnt) <> "ent" "ents"
        (tuple.Tuple__WriteOpen (struct.get WrEnt "tpl" "ent"));;
      #true).

Definition WrBuf__UpdateTuples: val :=
  rec: "WrBuf__UpdateTuples" "wrbuf" "tid" :=
    let: "ents" := struct.loadF WrBuf "ents" "wrbuf" in
    ForSlice (struct.t WrEnt) <> "ent" "ents"
      (let: "tpl" := struct.get WrEnt "tpl" "ent" in
      (if: struct.get WrEnt "wr" "ent"
      then tuple.Tuple__AppendVersion "tpl" "tid" (struct.get WrEnt "val" "ent")
      else tuple.Tuple__KillVersion "tpl" "tid"));;
    #().

Definition WrBuf__Clear: val :=
  rec: "WrBuf__Clear" "wrbuf" :=
    struct.storeF WrBuf "ents" "wrbuf" (SliceTake (struct.loadF WrBuf "ents" "wrbuf") #0);;
    #().

End code.
