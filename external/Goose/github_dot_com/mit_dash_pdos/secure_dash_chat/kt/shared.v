(* autogenerated from github.com/mit-pdos/secure-chat/kt/shared *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition ErrorT: ty := uint64T.

Definition ErrNone : expr := #0.

Definition ErrGeneric : expr := #1.

Definition ErrVerify : expr := #2.

Definition ErrUnameKey_Decode : expr := #3.

Definition ErrKeyLog_Decode : expr := #4.

Definition ErrSigLog_Decode : expr := #5.

Definition ErrInjestNewLog_Prefix : expr := #6.

Definition ErrKeyCli_RegNoExist : expr := #7.

Definition ErrKeyCli_LookNoExist : expr := #8.

Definition ErrKeyCli_AuditPrefix : expr := #9.

Definition RpcKeyServ_Put : expr := #1.

Definition RpcKeyServ_Get : expr := #2.

Definition RpcAdtr_Update : expr := #3.

Definition RpcAdtr_Get : expr := #4.

Definition SigLen : expr := #69.

Definition BytesEqual: val :=
  rec: "BytesEqual" "b1" "b2" :=
    (if: (slice.len "b1") ≠ (slice.len "b2")
    then #false
    else
      let: "ans" := ref_to boolT #true in
      ForSlice byteT "i" "b" "b1"
        ((if: "b" ≠ (SliceGet byteT "b2" "i")
        then "ans" <-[boolT] #false
        else #()));;
      ![boolT] "ans").

Definition UnameKey := struct.decl [
  "Uname" :: uint64T;
  "Key" :: slice.T byteT
].

Definition UnameKey__DeepCopy: val :=
  rec: "UnameKey__DeepCopy" "uk" :=
    let: "newKey" := NewSlice byteT (slice.len (struct.loadF UnameKey "Key" "uk")) in
    SliceCopy byteT "newKey" (struct.loadF UnameKey "Key" "uk");;
    struct.new UnameKey [
      "Uname" ::= struct.loadF UnameKey "Uname" "uk";
      "Key" ::= "newKey"
    ].

Definition UnameKey__IsEqual: val :=
  rec: "UnameKey__IsEqual" "uk1" "uk2" :=
    ((struct.loadF UnameKey "Uname" "uk1") = (struct.loadF UnameKey "Uname" "uk2")) && (BytesEqual (struct.loadF UnameKey "Key" "uk1") (struct.loadF UnameKey "Key" "uk2")).

Definition UnameKey__Encode: val :=
  rec: "UnameKey__Encode" "uk" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF UnameKey "Uname" "uk"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (slice.len (struct.loadF UnameKey "Key" "uk")));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF UnameKey "Key" "uk"));;
    ![slice.T byteT] "b".

Definition UnameKey__Decode: val :=
  rec: "UnameKey__Decode" "uk" "b" :=
    (if: (slice.len "b") < #8
    then (slice.nil, ErrUnameKey_Decode)
    else
      let: ("uname", "b") := marshal.ReadInt "b" in
      (if: (slice.len "b") < #8
      then (slice.nil, ErrUnameKey_Decode)
      else
        let: ("l", "b") := marshal.ReadInt "b" in
        (if: (slice.len "b") < "l"
        then (slice.nil, ErrUnameKey_Decode)
        else
          let: ("key", "b") := marshal.ReadBytes "b" "l" in
          struct.storeF UnameKey "Uname" "uk" "uname";;
          struct.storeF UnameKey "Key" "uk" "key";;
          ("b", ErrNone)))).

Definition KeyLog := struct.decl [
  "log" :: slice.T ptrT
].

Definition NewKeyLog: val :=
  rec: "NewKeyLog" <> :=
    struct.new KeyLog [
      "log" ::= NewSlice ptrT #0
    ].

Definition KeyLog__Len: val :=
  rec: "KeyLog__Len" "l" :=
    slice.len (struct.loadF KeyLog "log" "l").

Definition KeyLog__DeepCopy: val :=
  rec: "KeyLog__DeepCopy" "l" :=
    let: "newLog" := ref_to (slice.T ptrT) (NewSliceWithCap ptrT #0 (KeyLog__Len "l")) in
    ForSlice ptrT <> "entry" (struct.loadF KeyLog "log" "l")
      ("newLog" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "newLog") (UnameKey__DeepCopy "entry")));;
    struct.new KeyLog [
      "log" ::= ![slice.T ptrT] "newLog"
    ].

Definition KeyLog__IsPrefix: val :=
  rec: "KeyLog__IsPrefix" "small" "big" :=
    (if: (KeyLog__Len "big") < (KeyLog__Len "small")
    then #false
    else
      let: "ans" := ref_to boolT #true in
      ForSlice ptrT "i" "log" (struct.loadF KeyLog "log" "small")
        ((if: (~ (UnameKey__IsEqual "log" (SliceGet ptrT (struct.loadF KeyLog "log" "big") "i")))
        then "ans" <-[boolT] #false
        else #()));;
      ![boolT] "ans").

Definition KeyLog__Lookup: val :=
  rec: "KeyLog__Lookup" "l" "uname" :=
    let: "idx" := ref (zero_val uint64T) in
    let: "key" := ref (zero_val (slice.T byteT)) in
    let: "ok" := ref (zero_val boolT) in
    ForSlice ptrT "i" "entry" (struct.loadF KeyLog "log" "l")
      ((if: (struct.loadF UnameKey "Uname" "entry") = "uname"
      then
        "idx" <-[uint64T] "i";;
        "key" <-[slice.T byteT] (struct.loadF UnameKey "Key" "entry");;
        "ok" <-[boolT] #true
      else #()));;
    (![uint64T] "idx", ![slice.T byteT] "key", ![boolT] "ok").

Definition KeyLog__Append: val :=
  rec: "KeyLog__Append" "l" "uk" :=
    struct.storeF KeyLog "log" "l" (SliceAppend ptrT (struct.loadF KeyLog "log" "l") "uk");;
    #().

Definition KeyLog__Encode: val :=
  rec: "KeyLog__Encode" "l" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (KeyLog__Len "l"));;
    ForSlice ptrT <> "entry" (struct.loadF KeyLog "log" "l")
      ("b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (UnameKey__Encode "entry")));;
    ![slice.T byteT] "b".

Definition KeyLog__Decode: val :=
  rec: "KeyLog__Decode" "l" "b2" :=
    let: "b" := ref_to (slice.T byteT) "b2" in
    (if: (slice.len (![slice.T byteT] "b")) < #8
    then (slice.nil, ErrKeyLog_Decode)
    else
      let: ("length", "b") := marshal.ReadInt (![slice.T byteT] "b") in
      let: "log" := NewSlice ptrT "length" in
      let: "err" := ref (zero_val uint64T) in
      let: "i" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        SliceSet ptrT "log" (![uint64T] "i") (struct.alloc UnameKey (zero_val (struct.t UnameKey)));;
        let: "err2" := ref (zero_val uint64T) in
        let: ("0_ret", "1_ret") := UnameKey__Decode (SliceGet ptrT "log" (![uint64T] "i")) (![slice.T byteT] "b") in
        "b" <-[slice.T byteT] "0_ret";;
        "err2" <-[uint64T] "1_ret";;
        (if: (![uint64T] "err2") ≠ ErrNone
        then
          "err" <-[uint64T] (![uint64T] "err2");;
          Continue
        else Continue));;
      struct.storeF KeyLog "log" "l" "log";;
      (![slice.T byteT] "b", ![uint64T] "err")).

Definition SigLog := struct.decl [
  "Sig" :: slice.T byteT;
  "Log" :: ptrT
].

Definition SigLog__Encode: val :=
  rec: "SigLog__Encode" "l" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    control.impl.Assert ((slice.len (struct.loadF SigLog "Sig" "l")) = SigLen);;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF SigLog "Sig" "l"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (KeyLog__Encode (struct.loadF SigLog "Log" "l")));;
    ![slice.T byteT] "b".

Definition SigLog__Decode: val :=
  rec: "SigLog__Decode" "l" "b" :=
    (if: (slice.len "b") < SigLen
    then (slice.nil, ErrSigLog_Decode)
    else
      let: ("sig", "b") := marshal.ReadBytes "b" SigLen in
      let: "log" := struct.alloc KeyLog (zero_val (struct.t KeyLog)) in
      let: ("b", "err") := KeyLog__Decode "log" "b" in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        struct.storeF SigLog "Sig" "l" "sig";;
        struct.storeF SigLog "Log" "l" "log";;
        ("b", ErrNone))).

End code.
