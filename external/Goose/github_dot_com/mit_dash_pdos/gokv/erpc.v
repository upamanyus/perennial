(* autogenerated from github.com/mit-pdos/gokv/erpc *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require sync.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

(* Implements "exactly-once RPCs" with a reply table. *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "lastSeq" :: mapT uint64T;
  "lastReply" :: mapT (slice.T byteT);
  "nextCID" :: uint64T
].

Definition Server__HandleRequest: val :=
  rec: "Server__HandleRequest" "t" "handler" :=
    let: "handler" := ref_to ((slice.T byteT) -> ptrT -> unitT)%ht "handler" in
    let: "t" := ref_to ptrT "t" in
    return: ((λ: "raw_args" "reply",
       let: "cid" := ref_zero uint64T in
       let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "raw_args") in
       "raw_args" <-[slice.T byteT] "$a1";;
       "cid" <-[uint64T] "$a0";;
       let: "seq" := ref_zero uint64T in
       let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "raw_args") in
       "raw_args" <-[slice.T byteT] "$a1";;
       "seq" <-[uint64T] "$a0";;
       sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "t"));;
       let: "last" := ref_zero uint64T in
       let: "$a0" := Fst (MapGet (struct.loadF Server "lastSeq" (![ptrT] "t")) (![uint64T] "cid")) in
       "last" <-[uint64T] "$a0";;
       (if: (![uint64T] "seq") ≤ (![uint64T] "last")
       then
         let: "$a0" := Fst (MapGet (struct.loadF Server "lastReply" (![ptrT] "t")) (![uint64T] "cid")) in
         (![ptrT] "reply") <-[slice.T byteT] "$a0";;
         sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "t"));;
         return: (#())
       else #());;
       (![(arrowT unitT unitT)] "handler") (![slice.T byteT] "raw_args") (![ptrT] "reply");;
       let: "$a0" := ![uint64T] "seq" in
       MapInsert (struct.loadF Server "lastSeq" (![ptrT] "t")) (![uint64T] "cid") "$a0";;
       let: "$a0" := ![slice.T byteT] (![ptrT] "reply") in
       MapInsert (struct.loadF Server "lastReply" (![ptrT] "t")) (![uint64T] "cid") "$a0";;
       sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "t"));;
       #()
       )).

Definition Server__GetFreshCID: val :=
  rec: "Server__GetFreshCID" "t" :=
    let: "t" := ref_to ptrT "t" in
    sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "t"));;
    let: "r" := ref_zero uint64T in
    let: "$a0" := struct.loadF Server "nextCID" (![ptrT] "t") in
    "r" <-[uint64T] "$a0";;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF Server "nextCID" (![ptrT] "t")) #1 in
    struct.storeF Server "nextCID" (![ptrT] "t") "$a0";;
    sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "t"));;
    return: (![uint64T] "r").

Definition MakeServer: val :=
  rec: "MakeServer" <> :=
    let: "t" := ref_zero ptrT in
    let: "$a0" := struct.alloc Server (zero_val (struct.t Server)) in
    "t" <-[ptrT] "$a0";;
    let: "$a0" := NewMap uint64T (slice.T byteT) #() in
    struct.storeF Server "lastReply" (![ptrT] "t") "$a0";;
    let: "$a0" := NewMap uint64T uint64T #() in
    struct.storeF Server "lastSeq" (![ptrT] "t") "$a0";;
    let: "$a0" := #0 in
    struct.storeF Server "nextCID" (![ptrT] "t") "$a0";;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    struct.storeF Server "mu" (![ptrT] "t") "$a0";;
    return: (![ptrT] "t").

Definition Client := struct.decl [
  "cid" :: uint64T;
  "nextSeq" :: uint64T
].

Definition Client__NewRequest: val :=
  rec: "Client__NewRequest" "c" "request" :=
    let: "request" := ref_to (slice.T byteT) "request" in
    let: "c" := ref_to ptrT "c" in
    let: "seq" := ref_zero uint64T in
    let: "$a0" := struct.loadF Client "nextSeq" (![ptrT] "c") in
    "seq" <-[uint64T] "$a0";;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF Client "nextSeq" (![ptrT] "c")) #1 in
    struct.storeF Client "nextSeq" (![ptrT] "c") "$a0";;
    let: "data1" := ref_zero (slice.T byteT) in
    let: "$a0" := NewSliceWithCap byteT #0 ((#8 + #8) + (slice.len (![slice.T byteT] "request"))) in
    "data1" <-[slice.T byteT] "$a0";;
    let: "data2" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "data1") (struct.loadF Client "cid" (![ptrT] "c")) in
    "data2" <-[slice.T byteT] "$a0";;
    let: "data3" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "data2") (![uint64T] "seq") in
    "data3" <-[slice.T byteT] "$a0";;
    let: "data4" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "data3") (![slice.T byteT] "request") in
    "data4" <-[slice.T byteT] "$a0";;
    return: (![slice.T byteT] "data4").

Definition MakeClient: val :=
  rec: "MakeClient" "cid" :=
    let: "cid" := ref_to uint64T "cid" in
    let: "c" := ref_zero ptrT in
    let: "$a0" := struct.alloc Client (zero_val (struct.t Client)) in
    "c" <-[ptrT] "$a0";;
    let: "$a0" := ![uint64T] "cid" in
    struct.storeF Client "cid" (![ptrT] "c") "$a0";;
    let: "$a0" := #1 in
    struct.storeF Client "nextSeq" (![ptrT] "c") "$a0";;
    return: (![ptrT] "c").

End code.
