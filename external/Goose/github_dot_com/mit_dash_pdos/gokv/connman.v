(* autogenerated from github.com/mit-pdos/gokv/connman *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition HostName: ty := uint64T.

Definition ConnMan := struct.decl [
  "mu" :: ptrT;
  "rpcCls" :: mapT ptrT;
  "making" :: mapT ptrT
].

Definition MakeConnMan: val :=
  rec: "MakeConnMan" <> :=
    let: "c" := ref_zero ptrT in
    let: "$a0" := struct.alloc ConnMan (zero_val (struct.t ConnMan)) in
    "c" <-[ptrT] "$a0";;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    struct.storeF ConnMan "mu" (![ptrT] "c") "$a0";;
    let: "$a0" := NewMap uint64T ptrT #() in
    struct.storeF ConnMan "rpcCls" (![ptrT] "c") "$a0";;
    let: "$a0" := NewMap uint64T ptrT #() in
    struct.storeF ConnMan "making" (![ptrT] "c") "$a0";;
    return: (![ptrT] "c").

Definition ConnMan__getClient: val :=
  rec: "ConnMan__getClient" "c" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "c" := ref_to ptrT "c" in
    let: "ret" := ref (zero_val ptrT) in
    sync.Mutex__Lock (struct.loadF ConnMan "mu" (![ptrT] "c"));;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "ok" := ref_zero boolT in
      let: "cl" := ref_zero ptrT in
      let: ("$a0", "$a1") := Fst (MapGet (struct.loadF ConnMan "rpcCls" (![ptrT] "c")) (![uint64T] "host")) in
      "ok" <-[boolT] "$a1";;
      "cl" <-[ptrT] "$a0";;
      (if: ![boolT] "ok"
      then
        let: "$a0" := ![ptrT] "cl" in
        "ret" <-[ptrT] "$a0";;
        Break
      else #());;
      let: "cond" := ref_zero ptrT in
      let: ("$a0", "$a1") := Fst (MapGet (struct.loadF ConnMan "making" (![ptrT] "c")) (![uint64T] "host")) in
      "ok" <-[boolT] "$a1";;
      "cond" <-[ptrT] "$a0";;
      (if: ![boolT] "ok"
      then
        sync.Cond__Wait (![ptrT] "cond");;
        Continue
      else #());;
      let: "my_cond" := ref_zero ptrT in
      let: "$a0" := sync.NewCond (struct.loadF ConnMan "mu" (![ptrT] "c")) in
      "my_cond" <-[ptrT] "$a0";;
      let: "$a0" := ![ptrT] "my_cond" in
      MapInsert (struct.loadF ConnMan "making" (![ptrT] "c")) (![uint64T] "host") "$a0";;
      sync.Mutex__Unlock (struct.loadF ConnMan "mu" (![ptrT] "c"));;
      let: "$a0" := urpc.MakeClient (![uint64T] "host") in
      "ret" <-[ptrT] "$a0";;
      sync.Mutex__Lock (struct.loadF ConnMan "mu" (![ptrT] "c"));;
      let: "$a0" := ![ptrT] "ret" in
      MapInsert (struct.loadF ConnMan "rpcCls" (![ptrT] "c")) (![uint64T] "host") "$a0";;
      sync.Cond__Broadcast (![ptrT] "my_cond");;
      MapDelete (struct.loadF ConnMan "making" (![ptrT] "c")) (![uint64T] "host");;
      Break).

(* This repeatedly retries the RPC after retryTimeout until it gets a response. *)
Definition ConnMan__CallAtLeastOnce: val :=
  rec: "ConnMan__CallAtLeastOnce" "c" "host" "rpcid" "args" "reply" "retryTimeout" :=
    let: "retryTimeout" := ref_to uint64T "retryTimeout" in
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to (slice.T byteT) "args" in
    let: "rpcid" := ref_to uint64T "rpcid" in
    let: "host" := ref_to uint64T "host" in
    let: "c" := ref_to ptrT "c" in
    let: "cl" := ref (zero_val ptrT) in
    let: "$a0" := ConnMan__getClient (![ptrT] "c") (![uint64T] "host") in
    "cl" <-[ptrT] "$a0";;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := ref_zero uint64T in
      let: "$a0" := urpc.Client__Call (![ptrT] "cl") (![uint64T] "rpcid") (![slice.T byteT] "args") (![ptrT] "reply") (![uint64T] "retryTimeout") in
      "err" <-[uint64T] "$a0";;
      (if: (![uint64T] "err") = urpc.ErrTimeout
      then Continue
      else #());;
      (if: (![uint64T] "err") = urpc.ErrDisconnect
      then
        sync.Mutex__Lock (struct.loadF ConnMan "mu" (![ptrT] "c"));;
        (if: (![ptrT] "cl") = (Fst (MapGet (struct.loadF ConnMan "rpcCls" (![ptrT] "c")) (![uint64T] "host")))
        then
          MapDelete (struct.loadF ConnMan "rpcCls" (![ptrT] "c")) (![uint64T] "host");;
          #()
        else #());;
        sync.Mutex__Unlock (struct.loadF ConnMan "mu" (![ptrT] "c"));;
        let: "$a0" := ConnMan__getClient (![ptrT] "c") (![uint64T] "host") in
        "cl" <-[ptrT] "$a0";;
        Continue
      else #());;
      Break).
