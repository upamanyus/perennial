(* autogenerated from github.com/mit-pdos/gokv/connman *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition HostName: ty := uint64T.

Definition ConnMan := struct.decl [
  "mu" :: ptrT;
  "rpcCls" :: mapT ptrT;
  "making" :: mapT ptrT
].

Definition MakeConnMan: val :=
  rec: "MakeConnMan" <> :=
    let: "c" := struct.alloc ConnMan (zero_val (struct.t ConnMan)) in
    struct.storeF ConnMan "mu" "c" (struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)));;
    struct.storeF ConnMan "rpcCls" "c" (NewMap HostName ptrT #());;
    struct.storeF ConnMan "making" "c" (NewMap HostName ptrT #());;
    "c".

Definition ConnMan__getClient: val :=
  rec: "ConnMan__getClient" "c" "host" :=
    let: "ret" := ref (zero_val ptrT) in
    sync.Mutex__Lock (struct.loadF ConnMan "mu" "c");;
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("cl", "ok") := MapGet (struct.loadF ConnMan "rpcCls" "c") "host" in
      (if: "ok"
      then
        "ret" <-[ptrT] "cl";;
        Break
      else
        let: ("cond", "ok") := MapGet (struct.loadF ConnMan "making" "c") "host" in
        (if: "ok"
        then
          sync.Cond__Wait "cond";;
          Continue
        else
          let: "my_cond" := sync.NewCond (struct.loadF ConnMan "mu" "c") in
          MapInsert (struct.loadF ConnMan "making" "c") "host" "my_cond";;
          sync.Mutex__Unlock (struct.loadF ConnMan "mu" "c");;
          "ret" <-[ptrT] (urpc.MakeClient "host");;
          sync.Mutex__Lock (struct.loadF ConnMan "mu" "c");;
          MapInsert (struct.loadF ConnMan "rpcCls" "c") "host" (![ptrT] "ret");;
          sync.Cond__Broadcast "my_cond";;
          MapDelete (struct.loadF ConnMan "making" "c") "host";;
          Break)));;
    sync.Mutex__Unlock (struct.loadF ConnMan "mu" "c");;
    ![ptrT] "ret".

(* This repeatedly retries the RPC after retryTimeout until it gets a response. *)
Definition ConnMan__CallAtLeastOnce: val :=
  rec: "ConnMan__CallAtLeastOnce" "c" "host" "rpcid" "args" "reply" "retryTimeout" :=
    let: "cl" := ref (zero_val ptrT) in
    "cl" <-[ptrT] (ConnMan__getClient "c" "host");;
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := urpc.Client__Call (![ptrT] "cl") "rpcid" "args" "reply" "retryTimeout" in
      (if: "err" = urpc.ErrTimeout
      then Continue
      else
        (if: "err" = urpc.ErrDisconnect
        then
          sync.Mutex__Lock (struct.loadF ConnMan "mu" "c");;
          (if: (![ptrT] "cl") = (Fst (MapGet (struct.loadF ConnMan "rpcCls" "c") "host"))
          then MapDelete (struct.loadF ConnMan "rpcCls" "c") "host"
          else #());;
          sync.Mutex__Unlock (struct.loadF ConnMan "mu" "c");;
          "cl" <-[ptrT] (ConnMan__getClient "c" "host");;
          Continue
        else Break)));;
    #().
