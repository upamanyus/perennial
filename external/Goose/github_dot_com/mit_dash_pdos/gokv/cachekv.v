(* autogenerated from github.com/mit-pdos/gokv/cachekv *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.kv.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition cacheValue := struct.decl [
  "v" :: stringT;
  "l" :: uint64T
].

Definition CacheKv := struct.decl [
  "kv" :: ptrT;
  "mu" :: ptrT;
  "cache" :: mapT (struct.t cacheValue)
].

Definition DecodeValue: val :=
  rec: "DecodeValue" "v" :=
    let: "e" := ref_to (slice.T byteT) (StringToBytes (![stringT] "v")) in
    let: "vBytes" := ref_zero (slice.T byteT) in
    let: "l" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    "vBytes" <-[slice.T byteT] "$a1";;
    "l" <-[uint64T] "$a0";;
    return: (struct.mk cacheValue [
       "l" ::= ![uint64T] "l";
       "v" ::= StringFromBytes (![slice.T byteT] "vBytes")
     ]).

Definition EncodeValue: val :=
  rec: "EncodeValue" "c" :=
    let: "e" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.get cacheValue "l" (![struct.t cacheValue] "c")) in
    "e" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (StringToBytes (struct.get cacheValue "v" (![struct.t cacheValue] "c"))) in
    "e" <-[slice.T byteT] "$a0";;
    return: (StringFromBytes (![slice.T byteT] "e")).

Definition max: val :=
  rec: "max" "a" "b" :=
    (if: (![uint64T] "a") > (![uint64T] "b")
    then return: (![uint64T] "a")
    else #());;
    return: (![uint64T] "b").

Definition Make: val :=
  rec: "Make" "kv" :=
    return: (struct.new CacheKv [
       "kv" ::= ![ptrT] "kv";
       "mu" ::= struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex));
       "cache" ::= NewMap stringT (struct.t cacheValue) #()
     ]).

Definition CacheKv__Get: val :=
  rec: "CacheKv__Get" "k" "key" :=
    sync.Mutex__Lock (struct.loadF CacheKv "mu" (![ptrT] "k"));;
    let: "ok" := ref_zero boolT in
    let: "cv" := ref_zero (struct.t cacheValue) in
    let: ("$a0", "$a1") := Fst (MapGet (struct.loadF CacheKv "cache" (![ptrT] "k")) (![stringT] "key")) in
    "ok" <-[boolT] "$a1";;
    "cv" <-[struct.t cacheValue] "$a0";;
    let: "high" := ref_zero uint64T in
    let: <> := ref_zero uint64T in
    let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
    "high" <-[uint64T] "$a1";;
    "$a0";;
    (if: (![boolT] "ok") && ((![uint64T] "high") < (struct.get cacheValue "l" (![struct.t cacheValue] "cv")))
    then
      sync.Mutex__Unlock (struct.loadF CacheKv "mu" (![ptrT] "k"));;
      return: (struct.get cacheValue "v" (![struct.t cacheValue] "cv"))
    else #());;
    MapDelete (struct.loadF CacheKv "cache" (![ptrT] "k")) (![stringT] "key");;
    sync.Mutex__Unlock (struct.loadF CacheKv "mu" (![ptrT] "k"));;
    return: (struct.get cacheValue "v" (DecodeValue ((struct.loadF kv.Kv "Get" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key")))).

Definition CacheKv__GetAndCache: val :=
  rec: "CacheKv__GetAndCache" "k" "key" "cachetime" :=
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "enc" := ref_zero stringT in
      let: "$a0" := (struct.loadF kv.Kv "Get" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key") in
      "enc" <-[stringT] "$a0";;
      let: "old" := ref_zero (struct.t cacheValue) in
      let: "$a0" := DecodeValue (![stringT] "enc") in
      "old" <-[struct.t cacheValue] "$a0";;
      let: "latest" := ref_zero uint64T in
      let: <> := ref_zero uint64T in
      let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
      "latest" <-[uint64T] "$a1";;
      "$a0";;
      let: "newLeaseExpiration" := ref_zero uint64T in
      let: "$a0" := max ((![uint64T] "latest") + (![uint64T] "cachetime")) (struct.get cacheValue "l" (![struct.t cacheValue] "old")) in
      "newLeaseExpiration" <-[uint64T] "$a0";;
      let: "resp" := ref_zero stringT in
      let: "$a0" := (struct.loadF kv.Kv "ConditionalPut" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key") (![stringT] "enc") (EncodeValue (struct.mk cacheValue [
        "v" ::= struct.get cacheValue "v" (![struct.t cacheValue] "old");
        "l" ::= ![uint64T] "newLeaseExpiration"
      ])) in
      "resp" <-[stringT] "$a0";;
      (if: (![stringT] "resp") = #(str"ok")
      then
        sync.Mutex__Lock (struct.loadF CacheKv "mu" (![ptrT] "k"));;
        let: "$a0" := struct.mk cacheValue [
          "v" ::= struct.get cacheValue "v" (![struct.t cacheValue] "old");
          "l" ::= ![uint64T] "newLeaseExpiration"
        ] in
        MapInsert (struct.loadF CacheKv "cache" (![ptrT] "k")) (![stringT] "key") "$a0";;
        Break
      else #());;
      #()).

Definition CacheKv__Put: val :=
  rec: "CacheKv__Put" "k" "key" "val" :=
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "enc" := ref_zero stringT in
      let: "$a0" := (struct.loadF kv.Kv "Get" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key") in
      "enc" <-[stringT] "$a0";;
      let: "leaseExpiration" := ref_zero uint64T in
      let: "$a0" := struct.get cacheValue "l" (DecodeValue (![stringT] "enc")) in
      "leaseExpiration" <-[uint64T] "$a0";;
      let: <> := ref_zero uint64T in
      let: "earliest" := ref_zero uint64T in
      let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
      "$a1";;
      "earliest" <-[uint64T] "$a0";;
      (if: (![uint64T] "leaseExpiration") > (![uint64T] "earliest")
      then Continue
      else #());;
      let: "resp" := ref_zero stringT in
      let: "$a0" := (struct.loadF kv.Kv "ConditionalPut" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key") (![stringT] "enc") (EncodeValue (struct.mk cacheValue [
        "v" ::= ![stringT] "val";
        "l" ::= #0
      ])) in
      "resp" <-[stringT] "$a0";;
      (if: (![stringT] "resp") = #(str"ok")
      then Break
      else #());;
      #()).
