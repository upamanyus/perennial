(* autogenerated from github.com/mit-pdos/gokv/tutorial/objectstore/chunk *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.connman.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.trusted__hash.
From Goose Require github_dot_com.mit_dash_pdos.gokv.tutorial.objectstore.dir.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0data.go *)

Definition WriteChunkArgs := struct.decl [
  "WriteId" :: uint64T;
  "Chunk" :: slice.T byteT;
  "Index" :: uint64T
].

Definition MarshalWriteChunkArgs: val :=
  rec: "MarshalWriteChunkArgs" "args" :=
    Panic "TODO: marshalling";;
    #().

Definition ParseWriteChunkArgs: val :=
  rec: "ParseWriteChunkArgs" "data" :=
    Panic "TODO: marshalling";;
    #().

(* client.go *)

Definition WriteID: ty := uint64T.

Definition WriteChunkId : expr := #1.

Definition GetChunkId : expr := #2.

Definition ClerkPool := struct.decl [
  "cm" :: ptrT
].

Definition ClerkPool__WriteChunk: val :=
  rec: "ClerkPool__WriteChunk" "ck" "addr" "args" :=
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := MarshalWriteChunkArgs (![struct.t WriteChunkArgs] "args") in
    "req" <-[slice.T byteT] "$a0";;
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    "reply" <-[ptrT] "$a0";;
    connman.ConnMan__CallAtLeastOnce (struct.loadF ClerkPool "cm" (![ptrT] "ck")) (![uint64T] "addr") WriteChunkId (![slice.T byteT] "req") (![ptrT] "reply") #100;;
    #().

Definition ClerkPool__GetChunk: val :=
  rec: "ClerkPool__GetChunk" "ck" "addr" "content_hash" :=
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := StringToBytes (![stringT] "content_hash") in
    "req" <-[slice.T byteT] "$a0";;
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    "reply" <-[ptrT] "$a0";;
    connman.ConnMan__CallAtLeastOnce (struct.loadF ClerkPool "cm" (![ptrT] "ck")) (![uint64T] "addr") GetChunkId (![slice.T byteT] "req") (![ptrT] "reply") #100;;
    return: (![slice.T byteT] (![ptrT] "reply")).

(* server.go *)

Definition Server := struct.decl [
  "m" :: ptrT;
  "chunks" :: mapT (slice.T byteT);
  "dir" :: ptrT;
  "me" :: uint64T
].

Definition Server__WriteChunk: val :=
  rec: "Server__WriteChunk" "s" "args" :=
    let: "content_hash" := ref_zero stringT in
    let: "$a0" := trusted__hash.Hash (struct.get WriteChunkArgs "Chunk" (![struct.t WriteChunkArgs] "args")) in
    "content_hash" <-[stringT] "$a0";;
    sync.Mutex__Lock (struct.loadF Server "m" (![ptrT] "s"));;
    let: "$a0" := struct.get WriteChunkArgs "Chunk" (![struct.t WriteChunkArgs] "args") in
    MapInsert (struct.loadF Server "chunks" (![ptrT] "s")) (![stringT] "content_hash") "$a0";;
    sync.Mutex__Unlock (struct.loadF Server "m" (![ptrT] "s"));;
    dir.Clerk__RecordChunk (struct.loadF Server "dir" (![ptrT] "s")) (struct.mk dir.RecordChunkArgs [
      "WriteId" ::= struct.get WriteChunkArgs "WriteId" (![struct.t WriteChunkArgs] "args");
      "Server" ::= struct.loadF Server "me" (![ptrT] "s");
      "ContentHash" ::= ![stringT] "content_hash";
      "Index" ::= struct.get WriteChunkArgs "Index" (![struct.t WriteChunkArgs] "args")
    ]);;
    #().

Definition Server__GetChunk: val :=
  rec: "Server__GetChunk" "s" "content_hash" :=
    sync.Mutex__Lock (struct.loadF Server "m" (![ptrT] "s"));;
    let: "data" := ref_zero (slice.T byteT) in
    let: "$a0" := Fst (MapGet (struct.loadF Server "chunks" (![ptrT] "s")) (![stringT] "content_hash")) in
    "data" <-[slice.T byteT] "$a0";;
    sync.Mutex__Unlock (struct.loadF Server "m" (![ptrT] "s"));;
    return: (![slice.T byteT] "data").

Definition StartServer: val :=
  rec: "StartServer" "me" "dir_addr" :=
    let: "dir" := ref_zero ptrT in
    let: "$a0" := dir.MakeClerk (![uint64T] "dir_addr") in
    "dir" <-[ptrT] "$a0";;
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.new Server [
      "m" ::= struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex));
      "chunks" ::= NewMap stringT (slice.T byteT) #();
      "dir" ::= ![ptrT] "dir";
      "me" ::= ![uint64T] "me"
    ] in
    "s" <-[ptrT] "$a0";;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%!!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)h(MISSING)t #() in
    "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;
    let: "$a0" := (λ: "req" "reply",
      let: "args" := ref_zero (struct.t WriteChunkArgs) in
      let: "$a0" := ParseWriteChunkArgs (![slice.T byteT] "req") in
      "args" <-[struct.t WriteChunkArgs] "$a0";;
      Server__WriteChunk (![ptrT] "s") (![struct.t WriteChunkArgs] "args");;
      let: "$a0" := NewSlice byteT #0 in
      (![ptrT] "reply") <-[slice.T byteT] "$a0";;
      #()
      ) in
    MapInsert (![mapT (arrowT unitT unitT)] "handlers") WriteChunkId "$a0";;
    let: "$a0" := (λ: "req" "reply",
      let: "args" := ref_zero stringT in
      let: "$a0" := StringFromBytes (![slice.T byteT] "req") in
      "args" <-[stringT] "$a0";;
      let: "ret" := ref_zero (slice.T byteT) in
      let: "$a0" := Server__GetChunk (![ptrT] "s") (![stringT] "args") in
      "ret" <-[slice.T byteT] "$a0";;
      let: "$a0" := ![slice.T byteT] "ret" in
      (![ptrT] "reply") <-[slice.T byteT] "$a0";;
      #()
      ) in
    MapInsert (![mapT (arrowT unitT unitT)] "handlers") GetChunkId "$a0";;
    let: "server" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    "server" <-[ptrT] "$a0";;
    urpc.Server__Serve (![ptrT] "server") (![uint64T] "me");;
    #().
