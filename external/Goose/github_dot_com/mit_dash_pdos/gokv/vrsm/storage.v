(* autogenerated from github.com/mit-pdos/gokv/vrsm/storage *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.aof.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.replica.
From Goose Require github_dot_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition InMemoryStateMachine := struct.decl [
  "ApplyReadonly" :: ((slice.T byteT) -> (uint64T * (slice.T byteT)))%ht;
  "ApplyVolatile" :: ((slice.T byteT) -> (slice.T byteT))%ht;
  "GetState" :: (unitT -> (slice.T byteT))%ht;
  "SetState" :: ((slice.T byteT) -> uint64T -> unitT)%ht
].

Definition MAX_LOG_SIZE : expr := ((#64 * #1024) * #1024) * #1024.

(* File format:
   [N]u8: snapshot
   u64:   epoch
   u64:   nextIndex
   [*]op: ops in the format (op length ++ op)
   ?u8:    sealed; this is only present if the state is sealed in this epoch *)
Definition StateMachine := struct.decl [
  "fname" :: stringT;
  "logFile" :: ptrT;
  "logsize" :: uint64T;
  "sealed" :: boolT;
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "smMem" :: ptrT
].

(* FIXME: better name; this isn't the same as "MakeDurable" *)
Definition StateMachine__makeDurableWithSnap: val :=
  rec: "StateMachine__makeDurableWithSnap" "s" "snap" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (((#8 + (slice.len "snap")) + #8) + #8)) in
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (slice.len "snap"));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") "snap");;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF StateMachine "epoch" "s"));;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF StateMachine "nextIndex" "s"));;
    (if: struct.loadF StateMachine "sealed" "s"
    then marshal.WriteBytes (![slice.T byteT] "enc") (NewSlice byteT #1)
    else #());;
    aof.AppendOnlyFile__Close (struct.loadF StateMachine "logFile" "s");;
    grove_ffi.FileWrite (struct.loadF StateMachine "fname" "s") (![slice.T byteT] "enc");;
    struct.storeF StateMachine "logFile" "s" (aof.CreateAppendOnlyFile (struct.loadF StateMachine "fname" "s"));;
    #().

(* XXX: this is not safe to run concurrently with apply()
   requires that the state machine is not sealed *)
Definition StateMachine__truncateAndMakeDurable: val :=
  rec: "StateMachine__truncateAndMakeDurable" "s" :=
    let: "snap" := (struct.loadF InMemoryStateMachine "GetState" (struct.loadF StateMachine "smMem" "s")) #() in
    StateMachine__makeDurableWithSnap "s" "snap";;
    #().

Definition StateMachine__apply: val :=
  rec: "StateMachine__apply" "s" "op" :=
    let: "ret" := (struct.loadF InMemoryStateMachine "ApplyVolatile" (struct.loadF StateMachine "smMem" "s")) "op" in
    struct.storeF StateMachine "nextIndex" "s" (std.SumAssumeNoOverflow (struct.loadF StateMachine "nextIndex" "s") #1);;
    struct.storeF StateMachine "logsize" "s" ((struct.loadF StateMachine "logsize" "s") + (slice.len "op"));;
    let: "opWithLen" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + (slice.len "op"))) in
    "opWithLen" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "opWithLen") (slice.len "op"));;
    "opWithLen" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "opWithLen") "op");;
    let: "l" := aof.AppendOnlyFile__Append (struct.loadF StateMachine "logFile" "s") (![slice.T byteT] "opWithLen") in
    let: "f" := struct.loadF StateMachine "logFile" "s" in
    let: "waitFn" := (λ: <>,
      aof.AppendOnlyFile__WaitAppend "f" "l";;
      #()
      ) in
    ("ret", "waitFn").

Definition StateMachine__applyReadonly: val :=
  rec: "StateMachine__applyReadonly" "s" "op" :=
    (struct.loadF InMemoryStateMachine "ApplyReadonly" (struct.loadF StateMachine "smMem" "s")) "op".

(* TODO: make the nextIndex and epoch argument order consistent with replica.StateMachine *)
Definition StateMachine__setStateAndUnseal: val :=
  rec: "StateMachine__setStateAndUnseal" "s" "snap" "nextIndex" "epoch" :=
    struct.storeF StateMachine "epoch" "s" "epoch";;
    struct.storeF StateMachine "nextIndex" "s" "nextIndex";;
    struct.storeF StateMachine "sealed" "s" #false;;
    (struct.loadF InMemoryStateMachine "SetState" (struct.loadF StateMachine "smMem" "s")) "snap" "nextIndex";;
    StateMachine__makeDurableWithSnap "s" "snap";;
    #().

Definition StateMachine__getStateAndSeal: val :=
  rec: "StateMachine__getStateAndSeal" "s" :=
    (if: (~ (struct.loadF StateMachine "sealed" "s"))
    then
      struct.storeF StateMachine "sealed" "s" #true;;
      let: "l" := aof.AppendOnlyFile__Append (struct.loadF StateMachine "logFile" "s") (NewSlice byteT #1) in
      aof.AppendOnlyFile__WaitAppend (struct.loadF StateMachine "logFile" "s") "l"
    else #());;
    let: "snap" := (struct.loadF InMemoryStateMachine "GetState" (struct.loadF StateMachine "smMem" "s")) #() in
    "snap".

Definition recoverStateMachine: val :=
  rec: "recoverStateMachine" "smMem" "fname" :=
    let: "s" := struct.new StateMachine [
      "fname" ::= "fname";
      "smMem" ::= "smMem"
    ] in
    let: "enc" := ref_to (slice.T byteT) (grove_ffi.FileRead (struct.loadF StateMachine "fname" "s")) in
    (if: (slice.len (![slice.T byteT] "enc")) = #0
    then
      let: "initState" := (struct.loadF InMemoryStateMachine "GetState" "smMem") #() in
      let: "initialContents" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (((#8 + (slice.len "initState")) + #8) + #8)) in
      "initialContents" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "initialContents") (slice.len "initState"));;
      "initialContents" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "initialContents") "initState");;
      "initialContents" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "initialContents") #0);;
      "initialContents" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "initialContents") #0);;
      grove_ffi.FileWrite (struct.loadF StateMachine "fname" "s") (![slice.T byteT] "initialContents");;
      struct.storeF StateMachine "logFile" "s" (aof.CreateAppendOnlyFile "fname");;
      "s"
    else
      struct.storeF StateMachine "logFile" "s" (aof.CreateAppendOnlyFile "fname");;
      let: "snapLen" := ref (zero_val uint64T) in
      let: "snap" := ref (zero_val (slice.T byteT)) in
      let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
      "snapLen" <-[uint64T] "0_ret";;
      "enc" <-[slice.T byteT] "1_ret";;
      "snap" <-[slice.T byteT] (SliceSubslice byteT (![slice.T byteT] "enc") #0 (![uint64T] "snapLen"));;
      let: "n" := slice.len (![slice.T byteT] "enc") in
      "enc" <-[slice.T byteT] (SliceSubslice byteT (![slice.T byteT] "enc") (![uint64T] "snapLen") "n");;
      let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
      struct.storeF StateMachine "epoch" "s" "0_ret";;
      "enc" <-[slice.T byteT] "1_ret";;
      let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
      struct.storeF StateMachine "nextIndex" "s" "0_ret";;
      "enc" <-[slice.T byteT] "1_ret";;
      (struct.loadF InMemoryStateMachine "SetState" (struct.loadF StateMachine "smMem" "s")) (![slice.T byteT] "snap") (struct.loadF StateMachine "nextIndex" "s");;
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: (slice.len (![slice.T byteT] "enc")) > #1
        then
          let: "opLen" := ref (zero_val uint64T) in
          let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
          "opLen" <-[uint64T] "0_ret";;
          "enc" <-[slice.T byteT] "1_ret";;
          let: "op" := SliceSubslice byteT (![slice.T byteT] "enc") #0 (![uint64T] "opLen") in
          let: "n" := slice.len (![slice.T byteT] "enc") in
          "enc" <-[slice.T byteT] (SliceSubslice byteT (![slice.T byteT] "enc") (![uint64T] "opLen") "n");;
          (struct.loadF InMemoryStateMachine "ApplyVolatile" (struct.loadF StateMachine "smMem" "s")) "op";;
          struct.storeF StateMachine "nextIndex" "s" (std.SumAssumeNoOverflow (struct.loadF StateMachine "nextIndex" "s") #1);;
          Continue
        else Break));;
      (if: (slice.len (![slice.T byteT] "enc")) > #0
      then struct.storeF StateMachine "sealed" "s" #true
      else #());;
      "s").

(* XXX: putting this here because MakeServer takes nextIndex, epoch, and sealed
   as input, and the user of simplelog won't have access to the private fields
   index, epoch, etc.

   Maybe we should make those be a part of replica.StateMachine *)
Definition MakePbServer: val :=
  rec: "MakePbServer" "smMem" "fname" "confHosts" :=
    let: "s" := recoverStateMachine "smMem" "fname" in
    let: "sm" := struct.new replica.StateMachine [
      "StartApply" ::= (λ: "op",
        StateMachine__apply "s" "op"
        );
      "ApplyReadonly" ::= (λ: "op",
        StateMachine__applyReadonly "s" "op"
        );
      "SetStateAndUnseal" ::= (λ: "snap" "nextIndex" "epoch",
        StateMachine__setStateAndUnseal "s" "snap" "nextIndex" "epoch";;
        #()
        );
      "GetStateAndSeal" ::= (λ: <>,
        StateMachine__getStateAndSeal "s"
        )
    ] in
    replica.MakeServer "sm" "confHosts" (struct.loadF StateMachine "nextIndex" "s") (struct.loadF StateMachine "epoch" "s") (struct.loadF StateMachine "sealed" "s").
