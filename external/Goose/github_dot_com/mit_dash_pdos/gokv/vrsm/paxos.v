(* autogenerated from github.com/mit-pdos/gokv/vrsm/paxos *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.asyncfile.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.reconnectclient.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require log.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_marshal.go *)

Definition Error: ty := uint64T.

Definition ENone : expr := #0.

Definition EEpochStale : expr := #1.

Definition EOutOfOrder : expr := #2.

Definition ETimeout : expr := #3.

Definition ENotLeader : expr := #4.

Definition applyAsFollowerArgs := struct.decl [
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT
].

Definition encodeApplyAsFollowerArgs: val :=
  rec: "encodeApplyAsFollowerArgs" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 ((#8 + #8) + (slice.len (struct.loadF applyAsFollowerArgs "state" (![ptrT] "o"))))) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "nextIndex" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "state" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    return: (![slice.T byteT] "enc").

Definition decodeApplyAsFollowerArgs: val :=
  rec: "decodeApplyAsFollowerArgs" "s" :=
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "s") in
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc applyAsFollowerArgs (zero_val (struct.t applyAsFollowerArgs)) in
    "o" <-[ptrT] "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    "enc" <-[slice.T byteT] "$a1";;
    struct.storeF applyAsFollowerArgs "epoch" (![ptrT] "o") "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    "enc" <-[slice.T byteT] "$a1";;
    struct.storeF applyAsFollowerArgs "nextIndex" (![ptrT] "o") "$a0";;
    let: "$a0" := ![slice.T byteT] "enc" in
    struct.storeF applyAsFollowerArgs "state" (![ptrT] "o") "$a0";;
    return: (![ptrT] "o").

Definition applyAsFollowerReply := struct.decl [
  "err" :: Error
].

Definition decodeApplyAsFollowerReply: val :=
  rec: "decodeApplyAsFollowerReply" "s" :=
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc applyAsFollowerReply (zero_val (struct.t applyAsFollowerReply)) in
    "o" <-[ptrT] "$a0";;
    let: <> := ref_zero (slice.T byteT) in
    let: "err" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "s") in
    "$a1";;
    "err" <-[uint64T] "$a0";;
    let: "$a0" := ![uint64T] "err" in
    struct.storeF applyAsFollowerReply "err" (![ptrT] "o") "$a0";;
    return: (![ptrT] "o").

Definition encodeApplyAsFollowerReply: val :=
  rec: "encodeApplyAsFollowerReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerReply "err" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    return: (![slice.T byteT] "enc").

Definition enterNewEpochArgs := struct.decl [
  "epoch" :: uint64T
].

Definition encodeEnterNewEpochArgs: val :=
  rec: "encodeEnterNewEpochArgs" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochArgs "epoch" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    return: (![slice.T byteT] "enc").

Definition decodeEnterNewEpochArgs: val :=
  rec: "decodeEnterNewEpochArgs" "s" :=
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc enterNewEpochArgs (zero_val (struct.t enterNewEpochArgs)) in
    "o" <-[ptrT] "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "s") in
    "$a1";;
    struct.storeF enterNewEpochArgs "epoch" (![ptrT] "o") "$a0";;
    return: (![ptrT] "o").

Definition enterNewEpochReply := struct.decl [
  "err" :: Error;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT
].

Definition decodeEnterNewEpochReply: val :=
  rec: "decodeEnterNewEpochReply" "s" :=
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc enterNewEpochReply (zero_val (struct.t enterNewEpochReply)) in
    "o" <-[ptrT] "$a0";;
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "s") in
    let: "err" := ref (zero_val uint64T) in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    "enc" <-[slice.T byteT] "$a1";;
    "err" <-[uint64T] "$a0";;
    let: "$a0" := ![uint64T] "err" in
    struct.storeF enterNewEpochReply "err" (![ptrT] "o") "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    "enc" <-[slice.T byteT] "$a1";;
    struct.storeF enterNewEpochReply "acceptedEpoch" (![ptrT] "o") "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    "enc" <-[slice.T byteT] "$a1";;
    struct.storeF enterNewEpochReply "nextIndex" (![ptrT] "o") "$a0";;
    let: "$a0" := ![slice.T byteT] "enc" in
    struct.storeF enterNewEpochReply "state" (![ptrT] "o") "$a0";;
    return: (![ptrT] "o").

Definition encodeEnterNewEpochReply: val :=
  rec: "encodeEnterNewEpochReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (((#8 + #8) + #8) + (slice.len (struct.loadF enterNewEpochReply "state" (![ptrT] "o"))))) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "err" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "acceptedEpoch" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "nextIndex" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "state" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    return: (![slice.T byteT] "enc").

Definition applyReply := struct.decl [
  "err" :: Error;
  "ret" :: slice.T byteT
].

Definition encodeApplyReply: val :=
  rec: "encodeApplyReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + (slice.len (struct.loadF applyReply "ret" (![ptrT] "o"))))) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyReply "err" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF applyReply "ret" (![ptrT] "o")) in
    "enc" <-[slice.T byteT] "$a0";;
    return: (![slice.T byteT] "enc").

Definition decodeApplyReply: val :=
  rec: "decodeApplyReply" "s" :=
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "s") in
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc applyReply (zero_val (struct.t applyReply)) in
    "o" <-[ptrT] "$a0";;
    let: "err" := ref (zero_val uint64T) in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    "enc" <-[slice.T byteT] "$a1";;
    "err" <-[uint64T] "$a0";;
    let: "$a0" := ![uint64T] "err" in
    struct.storeF applyReply "err" (![ptrT] "o") "$a0";;
    let: "$a0" := ![slice.T byteT] "enc" in
    struct.storeF applyReply "ret" (![ptrT] "o") "$a0";;
    return: (![ptrT] "o").

Definition boolToU64: val :=
  rec: "boolToU64" "b" :=
    (if: ![boolT] "b"
    then return: (#1)
    else return: (#0));;
    #().

(* paxosState from server.go *)

Definition paxosState := struct.decl [
  "epoch" :: uint64T;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT;
  "isLeader" :: boolT
].

Definition encodePaxosState: val :=
  rec: "encodePaxosState" "ps" :=
    let: "e" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "epoch" (![ptrT] "ps")) in
    "e" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "acceptedEpoch" (![ptrT] "ps")) in
    "e" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "nextIndex" (![ptrT] "ps")) in
    "e" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (boolToU64 (struct.loadF paxosState "isLeader" (![ptrT] "ps"))) in
    "e" <-[slice.T byteT] "$a0";;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (struct.loadF paxosState "state" (![ptrT] "ps")) in
    "e" <-[slice.T byteT] "$a0";;
    return: (![slice.T byteT] "e").

Definition decodePaxosState: val :=
  rec: "decodePaxosState" "enc" :=
    let: "e" := ref_to (slice.T byteT) (![slice.T byteT] "enc") in
    let: "leaderInt" := ref (zero_val uint64T) in
    let: "ps" := ref_zero ptrT in
    let: "$a0" := struct.alloc paxosState (zero_val (struct.t paxosState)) in
    "ps" <-[ptrT] "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    "e" <-[slice.T byteT] "$a1";;
    struct.storeF paxosState "epoch" (![ptrT] "ps") "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    "e" <-[slice.T byteT] "$a1";;
    struct.storeF paxosState "acceptedEpoch" (![ptrT] "ps") "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    "e" <-[slice.T byteT] "$a1";;
    struct.storeF paxosState "nextIndex" (![ptrT] "ps") "$a0";;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    struct.storeF paxosState "state" (![ptrT] "ps") "$a1";;
    "leaderInt" <-[uint64T] "$a0";;
    let: "$a0" := (![uint64T] "leaderInt") = #1 in
    struct.storeF paxosState "isLeader" (![ptrT] "ps") "$a0";;
    return: (![ptrT] "ps").

(* 2_internalclerk.go *)

Definition RPC_APPLY_AS_FOLLOWER : expr := #0.

Definition RPC_ENTER_NEW_EPOCH : expr := #1.

Definition RPC_BECOME_LEADER : expr := #2.

Definition singleClerk := struct.decl [
  "cl" :: ptrT
].

Definition MakeSingleClerk: val :=
  rec: "MakeSingleClerk" "addr" :=
    let: "ck" := ref_zero ptrT in
    let: "$a0" := struct.new singleClerk [
      "cl" ::= reconnectclient.MakeReconnectingClient (![uint64T] "addr")
    ] in
    "ck" <-[ptrT] "$a0";;
    return: (![ptrT] "ck").

Definition singleClerk__enterNewEpoch: val :=
  rec: "singleClerk__enterNewEpoch" "s" "args" :=
    let: "raw_args" := ref_zero (slice.T byteT) in
    let: "$a0" := encodeEnterNewEpochArgs (![ptrT] "args") in
    "raw_args" <-[slice.T byteT] "$a0";;
    let: "raw_reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    "raw_reply" <-[ptrT] "$a0";;
    let: "err" := ref_zero uint64T in
    let: "$a0" := reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" (![ptrT] "s")) RPC_ENTER_NEW_EPOCH (![slice.T byteT] "raw_args") (![ptrT] "raw_reply") #500 in
    "err" <-[uint64T] "$a0";;
    (if: (![uint64T] "err") = #0
    then return: (decodeEnterNewEpochReply (![slice.T byteT] (![ptrT] "raw_reply")))
    else
      return: (struct.new enterNewEpochReply [
         "err" ::= ETimeout
       ]));;
    #().

Definition singleClerk__applyAsFollower: val :=
  rec: "singleClerk__applyAsFollower" "s" "args" :=
    let: "raw_args" := ref_zero (slice.T byteT) in
    let: "$a0" := encodeApplyAsFollowerArgs (![ptrT] "args") in
    "raw_args" <-[slice.T byteT] "$a0";;
    let: "raw_reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    "raw_reply" <-[ptrT] "$a0";;
    let: "err" := ref_zero uint64T in
    let: "$a0" := reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" (![ptrT] "s")) RPC_APPLY_AS_FOLLOWER (![slice.T byteT] "raw_args") (![ptrT] "raw_reply") #500 in
    "err" <-[uint64T] "$a0";;
    (if: (![uint64T] "err") = #0
    then return: (decodeApplyAsFollowerReply (![slice.T byteT] (![ptrT] "raw_reply")))
    else
      return: (struct.new applyAsFollowerReply [
         "err" ::= ETimeout
       ]));;
    #().

Definition singleClerk__TryBecomeLeader: val :=
  rec: "singleClerk__TryBecomeLeader" "s" :=
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    "reply" <-[ptrT] "$a0";;
    reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" (![ptrT] "s")) RPC_BECOME_LEADER (NewSlice byteT #0) (![ptrT] "reply") #500;;
    #().

(* server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "ps" :: ptrT;
  "storage" :: ptrT;
  "clerks" :: slice.T ptrT
].

Definition Server__withLock: val :=
  rec: "Server__withLock" "s" "f" :=
    sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;
    (![(arrowT unitT unitT)] "f") (struct.loadF Server "ps" (![ptrT] "s"));;
    let: "waitFn" := ref_zero (arrowT unitT unitT) in
    let: "$a0" := asyncfile.AsyncFile__Write (struct.loadF Server "storage" (![ptrT] "s")) (encodePaxosState (struct.loadF Server "ps" (![ptrT] "s"))) in
    "waitFn" <-[(arrowT unitT unitT)] "$a0";;
    sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;
    (![(arrowT unitT unitT)] "waitFn") #();;
    #().

Definition Server__applyAsFollower: val :=
  rec: "Server__applyAsFollower" "s" "args" "reply" :=
    Server__withLock (![ptrT] "s") (λ: "ps",
      (if: (struct.loadF paxosState "epoch" (![ptrT] "ps")) ≤ (struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "args"))
      then
        (if: (struct.loadF paxosState "acceptedEpoch" (![ptrT] "ps")) = (struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "args"))
        then
          (if: (struct.loadF paxosState "nextIndex" (![ptrT] "ps")) < (struct.loadF applyAsFollowerArgs "nextIndex" (![ptrT] "args"))
          then
            let: "$a0" := struct.loadF applyAsFollowerArgs "nextIndex" (![ptrT] "args") in
            struct.storeF paxosState "nextIndex" (![ptrT] "ps") "$a0";;
            let: "$a0" := struct.loadF applyAsFollowerArgs "state" (![ptrT] "args") in
            struct.storeF paxosState "state" (![ptrT] "ps") "$a0";;
            let: "$a0" := ENone in
            struct.storeF applyAsFollowerReply "err" (![ptrT] "reply") "$a0";;
            #()
          else
            let: "$a0" := ENone in
            struct.storeF applyAsFollowerReply "err" (![ptrT] "reply") "$a0";;
            #());;
          #()
        else
          let: "$a0" := struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "args") in
          struct.storeF paxosState "acceptedEpoch" (![ptrT] "ps") "$a0";;
          let: "$a0" := struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "args") in
          struct.storeF paxosState "epoch" (![ptrT] "ps") "$a0";;
          let: "$a0" := struct.loadF applyAsFollowerArgs "state" (![ptrT] "args") in
          struct.storeF paxosState "state" (![ptrT] "ps") "$a0";;
          let: "$a0" := struct.loadF applyAsFollowerArgs "nextIndex" (![ptrT] "args") in
          struct.storeF paxosState "nextIndex" (![ptrT] "ps") "$a0";;
          let: "$a0" := #false in
          struct.storeF paxosState "isLeader" (![ptrT] "ps") "$a0";;
          let: "$a0" := ENone in
          struct.storeF applyAsFollowerReply "err" (![ptrT] "reply") "$a0";;
          #());;
        #()
      else
        let: "$a0" := EEpochStale in
        struct.storeF applyAsFollowerReply "err" (![ptrT] "reply") "$a0";;
        #());;
      #()
      );;
    #().

(* NOTE:
   This will vote yes only the first time it's called in an epoch.
   If you have too aggressive of a timeout and end up retrying this, the retry
   might fail because it may be the second execution of enterNewEpoch(epoch) on
   the server.
   Solution: either conservative (maybe double) timeouts, or don't use this for
   leader election, only for coming up with a valid proposal. *)
Definition Server__enterNewEpoch: val :=
  rec: "Server__enterNewEpoch" "s" "args" "reply" :=
    Server__withLock (![ptrT] "s") (λ: "ps",
      (if: (struct.loadF paxosState "epoch" (![ptrT] "ps")) ≥ (struct.loadF enterNewEpochArgs "epoch" (![ptrT] "args"))
      then
        let: "$a0" := EEpochStale in
        struct.storeF enterNewEpochReply "err" (![ptrT] "reply") "$a0";;
        return: (#())
      else #());;
      let: "$a0" := #false in
      struct.storeF paxosState "isLeader" (![ptrT] "ps") "$a0";;
      let: "$a0" := struct.loadF enterNewEpochArgs "epoch" (![ptrT] "args") in
      struct.storeF paxosState "epoch" (![ptrT] "ps") "$a0";;
      let: "$a0" := struct.loadF paxosState "acceptedEpoch" (![ptrT] "ps") in
      struct.storeF enterNewEpochReply "acceptedEpoch" (![ptrT] "reply") "$a0";;
      let: "$a0" := struct.loadF paxosState "nextIndex" (![ptrT] "ps") in
      struct.storeF enterNewEpochReply "nextIndex" (![ptrT] "reply") "$a0";;
      let: "$a0" := struct.loadF paxosState "state" (![ptrT] "ps") in
      struct.storeF enterNewEpochReply "state" (![ptrT] "reply") "$a0";;
      #()
      );;
    #().

Definition Server__TryBecomeLeader: val :=
  rec: "Server__TryBecomeLeader" "s" :=
    log.Println #(str"started trybecomeleader");;
    sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;
    (if: struct.loadF paxosState "isLeader" (struct.loadF Server "ps" (![ptrT] "s"))
    then
      log.Println #(str"already leader");;
      sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;
      return: (#())
    else #());;
    let: "clerks" := ref_zero (slice.T ptrT) in
    let: "$a0" := struct.loadF Server "clerks" (![ptrT] "s") in
    "clerks" <-[slice.T ptrT] "$a0";;
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.new enterNewEpochArgs [
      "epoch" ::= (struct.loadF paxosState "epoch" (struct.loadF Server "ps" (![ptrT] "s"))) + #1
    ] in
    "args" <-[ptrT] "$a0";;
    sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;
    let: "numReplies" := ref_to uint64T #0 in
    let: "replies" := ref_zero (slice.T ptrT) in
    let: "$a0" := NewSlice ptrT (slice.len (![slice.T ptrT] "clerks")) in
    "replies" <-[slice.T ptrT] "$a0";;
    let: "mu" := ref_zero ptrT in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    "mu" <-[ptrT] "$a0";;
    let: "numReplies_cond" := ref_zero ptrT in
    let: "$a0" := sync.NewCond (![ptrT] "mu") in
    "numReplies_cond" <-[ptrT] "$a0";;
    let: "n" := ref_zero uint64T in
    let: "$a0" := slice.len (![slice.T ptrT] "clerks") in
    "n" <-[uint64T] "$a0";;
    ForSlice ptrT "i" "ck" (![slice.T ptrT] "clerks")
      (let: "ck" := ref_zero ptrT in
      let: "$a0" := ![ptrT] "ck" in
      "ck" <-[ptrT] "$a0";;
      let: "i" := ref_zero intT in
      let: "$a0" := ![intT] "i" in
      "i" <-[intT] "$a0";;
      Fork (let: "reply" := ref_zero ptrT in
            let: "$a0" := singleClerk__enterNewEpoch (![ptrT] "ck") (![ptrT] "args") in
            "reply" <-[ptrT] "$a0";;
            sync.Mutex__Lock (![ptrT] "mu");;
            "numReplies" <-[uint64T] ((![uint64T] "numReplies") + #1);;
            let: "$a0" := ![ptrT] "reply" in
            SliceSet ptrT (![slice.T ptrT] "replies") (![intT] "i") "$a0";;
            (if: (#2 * (![uint64T] "numReplies")) > (![uint64T] "n")
            then
              sync.Cond__Signal (![ptrT] "numReplies_cond");;
              #()
            else #());;
            sync.Mutex__Unlock (![ptrT] "mu");;
            #());;
      #());;
    sync.Mutex__Lock (![ptrT] "mu");;
    (for: (λ: <>, (#2 * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, Skip) := λ: <>,
      sync.Cond__Wait (![ptrT] "numReplies_cond");;
      #()).

Definition Server__TryAcquire: val :=
  rec: "Server__TryAcquire" "s" :=
    let: "retErr" := ref (zero_val Error) in
    sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;
    (if: (~ (struct.loadF paxosState "isLeader" (struct.loadF Server "ps" (![ptrT] "s"))))
    then
      sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;
      let: "n" := ref (zero_val ptrT) in
      return: (ENotLeader, ![ptrT] "n", slice.nil)
    else #());;
    let: "tryRelease" := ref_zero (arrowT unitT unitT) in
    let: "$a0" := (λ: <>,
      let: "$a0" := std.SumAssumeNoOverflow (struct.loadF paxosState "nextIndex" (struct.loadF Server "ps" (![ptrT] "s"))) #1 in
      struct.storeF paxosState "nextIndex" (struct.loadF Server "ps" (![ptrT] "s")) "$a0";;
      let: "args" := ref_zero ptrT in
      let: "$a0" := struct.new applyAsFollowerArgs [
        "epoch" ::= struct.loadF paxosState "epoch" (struct.loadF Server "ps" (![ptrT] "s"));
        "nextIndex" ::= struct.loadF paxosState "nextIndex" (struct.loadF Server "ps" (![ptrT] "s"));
        "state" ::= struct.loadF paxosState "state" (struct.loadF Server "ps" (![ptrT] "s"))
      ] in
      "args" <-[ptrT] "$a0";;
      let: "waitFn" := ref_zero (arrowT unitT unitT) in
      let: "$a0" := asyncfile.AsyncFile__Write (struct.loadF Server "storage" (![ptrT] "s")) (encodePaxosState (struct.loadF Server "ps" (![ptrT] "s"))) in
      "waitFn" <-[(arrowT unitT unitT)] "$a0";;
      sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;
      (![(arrowT unitT unitT)] "waitFn") #();;
      let: "clerks" := ref_zero (slice.T ptrT) in
      let: "$a0" := struct.loadF Server "clerks" (![ptrT] "s") in
      "clerks" <-[slice.T ptrT] "$a0";;
      let: "numReplies" := ref_to uint64T #0 in
      let: "replies" := ref_zero (slice.T ptrT) in
      let: "$a0" := NewSlice ptrT (slice.len (![slice.T ptrT] "clerks")) in
      "replies" <-[slice.T ptrT] "$a0";;
      let: "mu" := ref_zero ptrT in
      let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
      "mu" <-[ptrT] "$a0";;
      let: "numReplies_cond" := ref_zero ptrT in
      let: "$a0" := sync.NewCond (![ptrT] "mu") in
      "numReplies_cond" <-[ptrT] "$a0";;
      let: "n" := ref_zero uint64T in
      let: "$a0" := slice.len (![slice.T ptrT] "clerks") in
      "n" <-[uint64T] "$a0";;
      ForSlice ptrT "i" "ck" (![slice.T ptrT] "clerks")
        (let: "ck" := ref_zero ptrT in
        let: "$a0" := ![ptrT] "ck" in
        "ck" <-[ptrT] "$a0";;
        let: "i" := ref_zero intT in
        let: "$a0" := ![intT] "i" in
        "i" <-[intT] "$a0";;
        Fork (let: "reply" := ref_zero ptrT in
              let: "$a0" := singleClerk__applyAsFollower (![ptrT] "ck") (![ptrT] "args") in
              "reply" <-[ptrT] "$a0";;
              sync.Mutex__Lock (![ptrT] "mu");;
              "numReplies" <-[uint64T] ((![uint64T] "numReplies") + #1);;
              let: "$a0" := ![ptrT] "reply" in
              SliceSet ptrT (![slice.T ptrT] "replies") (![intT] "i") "$a0";;
              (if: (#2 * (![uint64T] "numReplies")) > (![uint64T] "n")
              then
                sync.Cond__Signal (![ptrT] "numReplies_cond");;
                #()
              else #());;
              sync.Mutex__Unlock (![ptrT] "mu");;
              #());;
        #());;
      sync.Mutex__Lock (![ptrT] "mu");;
      (for: (λ: <>, (#2 * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, Skip) := λ: <>,
        sync.Cond__Wait (![ptrT] "numReplies_cond");;
        #())
      ) in
    "tryRelease" <-[(arrowT unitT unitT)] "$a0";;
    return: (ENone, struct.fieldRef paxosState "state" (struct.loadF Server "ps" (![ptrT] "s")), ![(arrowT unitT unitT)] "tryRelease").

Definition Server__WeakRead: val :=
  rec: "Server__WeakRead" "s" :=
    sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;
    let: "ret" := ref_zero (slice.T byteT) in
    let: "$a0" := struct.loadF paxosState "state" (struct.loadF Server "ps" (![ptrT] "s")) in
    "ret" <-[slice.T byteT] "$a0";;
    sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;
    return: (![slice.T byteT] "ret").

Definition makeServer: val :=
  rec: "makeServer" "fname" "initstate" "config" :=
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc Server (zero_val (struct.t Server)) in
    "s" <-[ptrT] "$a0";;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    struct.storeF Server "mu" (![ptrT] "s") "$a0";;
    let: "$a0" := NewSlice ptrT #0 in
    struct.storeF Server "clerks" (![ptrT] "s") "$a0";;
    ForSlice uint64T <> "host" (![slice.T uint64T] "config")
      (let: "$a0" := SliceAppend ptrT (struct.loadF Server "clerks" (![ptrT] "s")) (MakeSingleClerk (![uint64T] "host")) in
      struct.storeF Server "clerks" (![ptrT] "s") "$a0";;
      #());;
    let: "encstate" := ref (zero_val (slice.T byteT)) in
    let: ("$a0", "$a1") := asyncfile.MakeAsyncFile (![stringT] "fname") in
    struct.storeF Server "storage" (![ptrT] "s") "$a1";;
    "encstate" <-[slice.T byteT] "$a0";;
    (if: (slice.len (![slice.T byteT] "encstate")) = #0
    then
      let: "$a0" := struct.alloc paxosState (zero_val (struct.t paxosState)) in
      struct.storeF Server "ps" (![ptrT] "s") "$a0";;
      let: "$a0" := ![slice.T byteT] "initstate" in
      struct.storeF paxosState "state" (struct.loadF Server "ps" (![ptrT] "s")) "$a0";;
      #()
    else
      let: "$a0" := decodePaxosState (![slice.T byteT] "encstate") in
      struct.storeF Server "ps" (![ptrT] "s") "$a0";;
      #());;
    return: (![ptrT] "s").

Definition StartServer: val :=
  rec: "StartServer" "fname" "initstate" "me" "config" :=
    let: "s" := ref_zero ptrT in
    let: "$a0" := makeServer (![stringT] "fname") (![slice.T byteT] "initstate") (![slice.T uint64T] "config") in
    "s" <-[ptrT] "$a0";;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%!!(MISSING)!(MISSING)!(MISSING)h(MISSING)t #() in
    "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      let: "reply" := ref_zero ptrT in
      let: "$a0" := struct.alloc applyAsFollowerReply (zero_val (struct.t applyAsFollowerReply)) in
      "reply" <-[ptrT] "$a0";;
      let: "args" := ref_zero ptrT in
      let: "$a0" := decodeApplyAsFollowerArgs (![slice.T byteT] "raw_args") in
      "args" <-[ptrT] "$a0";;
      Server__applyAsFollower (![ptrT] "s") (![ptrT] "args") (![ptrT] "reply");;
      let: "$a0" := encodeApplyAsFollowerReply (![ptrT] "reply") in
      (![ptrT] "raw_reply") <-[slice.T byteT] "$a0";;
      #()
      ) in
    MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_APPLY_AS_FOLLOWER "$a0";;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      let: "reply" := ref_zero ptrT in
      let: "$a0" := struct.alloc enterNewEpochReply (zero_val (struct.t enterNewEpochReply)) in
      "reply" <-[ptrT] "$a0";;
      let: "args" := ref_zero ptrT in
      let: "$a0" := decodeEnterNewEpochArgs (![slice.T byteT] "raw_args") in
      "args" <-[ptrT] "$a0";;
      Server__enterNewEpoch (![ptrT] "s") (![ptrT] "args") (![ptrT] "reply");;
      let: "$a0" := encodeEnterNewEpochReply (![ptrT] "reply") in
      (![ptrT] "raw_reply") <-[slice.T byteT] "$a0";;
      #()
      ) in
    MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_ENTER_NEW_EPOCH "$a0";;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      Server__TryBecomeLeader (![ptrT] "s");;
      #()
      ) in
    MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_BECOME_LEADER "$a0";;
    let: "r" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    "r" <-[ptrT] "$a0";;
    urpc.Server__Serve (![ptrT] "r") (![uint64T] "me");;
    return: (![ptrT] "s").
