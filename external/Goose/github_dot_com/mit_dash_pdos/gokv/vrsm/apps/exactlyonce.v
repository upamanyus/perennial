(* autogenerated from github.com/mit-pdos/gokv/vrsm/apps/exactlyonce *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.map__marshal.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.clerk.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.storage.
From Goose Require github_dot_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* sm.go *)

Definition eStateMachine := struct.decl [
  "lastSeq" :: mapT uint64T;
  "lastReply" :: mapT (slice.T byteT);
  "nextCID" :: uint64T;
  "sm" :: ptrT;
  "esmNextIndex" :: uint64T
].

Definition OPTYPE_RW : expr := #(U8 0).

Definition OPTYPE_GETFRESHCID : expr := #(U8 1).

Definition OPTYPE_RO : expr := #(U8 2).

(* VersionedStateMachine from vsm.go *)

Definition VersionedStateMachine := struct.decl [
  "ApplyVolatile" :: ((slice.T byteT) -> uint64T -> (slice.T byteT))%ht;
  "ApplyReadonly" :: ((slice.T byteT) -> (uint64T * (slice.T byteT)))%ht;
  "SetState" :: ((slice.T byteT) -> uint64T -> unitT)%ht;
  "GetState" :: (unitT -> (slice.T byteT))%ht
].

Definition eStateMachine__applyVolatile: val :=
  rec: "eStateMachine__applyVolatile" "s" "op" :=
    let: "ret" := ref (zero_val (slice.T byteT)) in
    struct.storeF eStateMachine "esmNextIndex" "s" (std.SumAssumeNoOverflow (struct.loadF eStateMachine "esmNextIndex" "s") #1);;
    (if: (SliceGet byteT "op" #0) = OPTYPE_GETFRESHCID
    then
      "ret" <-[slice.T byteT] (NewSliceWithCap byteT #0 #8);;
      "ret" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "ret") (struct.loadF eStateMachine "nextCID" "s"));;
      struct.storeF eStateMachine "nextCID" "s" (std.SumAssumeNoOverflow (struct.loadF eStateMachine "nextCID" "s") #1)
    else
      (if: (SliceGet byteT "op" #0) = OPTYPE_RW
      then
        let: "n" := slice.len "op" in
        let: "enc" := SliceSubslice byteT "op" #1 "n" in
        let: ("cid", "enc2") := marshal.ReadInt "enc" in
        let: ("seq", "realOp") := marshal.ReadInt "enc2" in
        (if: (Fst (MapGet (struct.loadF eStateMachine "lastSeq" "s") "cid")) ≥ "seq"
        then "ret" <-[slice.T byteT] (Fst (MapGet (struct.loadF eStateMachine "lastReply" "s") "cid"))
        else
          "ret" <-[slice.T byteT] ((struct.loadF VersionedStateMachine "ApplyVolatile" (struct.loadF eStateMachine "sm" "s")) "realOp" (struct.loadF eStateMachine "esmNextIndex" "s"));;
          MapInsert (struct.loadF eStateMachine "lastReply" "s") "cid" (![slice.T byteT] "ret");;
          MapInsert (struct.loadF eStateMachine "lastSeq" "s") "cid" "seq")
      else
        (if: (SliceGet byteT "op" #0) = OPTYPE_RO
        then
          let: "n" := slice.len "op" in
          let: "realOp" := SliceSubslice byteT "op" #1 "n" in
          let: ("0_ret", "1_ret") := (struct.loadF VersionedStateMachine "ApplyReadonly" (struct.loadF eStateMachine "sm" "s")) "realOp" in
          "0_ret";;
          "ret" <-[slice.T byteT] "1_ret"
        else Panic "unexpected ee op type")));;
    ![slice.T byteT] "ret".

Definition eStateMachine__applyReadonly: val :=
  rec: "eStateMachine__applyReadonly" "s" "op" :=
    (if: (SliceGet byteT "op" #0) = OPTYPE_GETFRESHCID
    then Panic "Got GETFRESHCID as a read-only op"
    else
      (if: (SliceGet byteT "op" #0) = OPTYPE_RW
      then Panic "Got RW as a read-only op"
      else
        (if: (SliceGet byteT "op" #0) ≠ OPTYPE_RO
        then Panic "unexpected ee op type"
        else #())));;
    let: "n" := slice.len "op" in
    let: "realOp" := SliceSubslice byteT "op" #1 "n" in
    (struct.loadF VersionedStateMachine "ApplyReadonly" (struct.loadF eStateMachine "sm" "s")) "realOp".

Definition eStateMachine__getState: val :=
  rec: "eStateMachine__getState" "s" :=
    let: "appState" := (struct.loadF VersionedStateMachine "GetState" (struct.loadF eStateMachine "sm" "s")) #() in
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #0) in
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF eStateMachine "nextCID" "s"));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (map__marshal.EncodeMapU64ToU64 (struct.loadF eStateMachine "lastSeq" "s")));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (map__marshal.EncodeMapU64ToBytes (struct.loadF eStateMachine "lastReply" "s")));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") "appState");;
    ![slice.T byteT] "enc".

Definition eStateMachine__setState: val :=
  rec: "eStateMachine__setState" "s" "state" "nextIndex" :=
    let: "enc" := ref_to (slice.T byteT) "state" in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF eStateMachine "nextCID" "s" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := map__marshal.DecodeMapU64ToU64 (![slice.T byteT] "enc") in
    struct.storeF eStateMachine "lastSeq" "s" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := map__marshal.DecodeMapU64ToBytes (![slice.T byteT] "enc") in
    struct.storeF eStateMachine "lastReply" "s" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    (struct.loadF VersionedStateMachine "SetState" (struct.loadF eStateMachine "sm" "s")) (![slice.T byteT] "enc") "nextIndex";;
    struct.storeF eStateMachine "esmNextIndex" "s" "nextIndex";;
    #().

Definition MakeExactlyOnceStateMachine: val :=
  rec: "MakeExactlyOnceStateMachine" "sm" :=
    let: "s" := struct.alloc eStateMachine (zero_val (struct.t eStateMachine)) in
    struct.storeF eStateMachine "lastSeq" "s" (NewMap uint64T uint64T #());;
    struct.storeF eStateMachine "lastReply" "s" (NewMap uint64T (slice.T byteT) #());;
    struct.storeF eStateMachine "nextCID" "s" #0;;
    struct.storeF eStateMachine "sm" "s" "sm";;
    struct.new storage.InMemoryStateMachine [
      "ApplyReadonly" ::= eStateMachine__applyReadonly "s";
      "ApplyVolatile" ::= eStateMachine__applyVolatile "s";
      "GetState" ::= (λ: <>,
        eStateMachine__getState "s"
        );
      "SetState" ::= eStateMachine__setState "s"
    ].

Definition Clerk := struct.decl [
  "ck" :: ptrT;
  "cid" :: uint64T;
  "seq" :: uint64T
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "confHosts" :=
    let: "ck" := struct.alloc Clerk (zero_val (struct.t Clerk)) in
    struct.storeF Clerk "ck" "ck" (clerk.Make "confHosts");;
    let: "v" := NewSlice byteT #1 in
    SliceSet byteT "v" #0 OPTYPE_GETFRESHCID;;
    let: "cidEnc" := clerk.Clerk__Apply (struct.loadF Clerk "ck" "ck") "v" in
    let: ("0_ret", "1_ret") := marshal.ReadInt "cidEnc" in
    struct.storeF Clerk "cid" "ck" "0_ret";;
    "1_ret";;
    struct.storeF Clerk "seq" "ck" #1;;
    "ck".

Definition Clerk__ApplyExactlyOnce: val :=
  rec: "Clerk__ApplyExactlyOnce" "ck" "req" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #1 #1) in
    SliceSet byteT (![slice.T byteT] "enc") #0 OPTYPE_RW;;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF Clerk "cid" "ck"));;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF Clerk "seq" "ck"));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") "req");;
    struct.storeF Clerk "seq" "ck" (std.SumAssumeNoOverflow (struct.loadF Clerk "seq" "ck") #1);;
    clerk.Clerk__Apply (struct.loadF Clerk "ck" "ck") (![slice.T byteT] "enc").

Definition Clerk__ApplyReadonly: val :=
  rec: "Clerk__ApplyReadonly" "ck" "req" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #1 #1) in
    SliceSet byteT (![slice.T byteT] "enc") #0 OPTYPE_RO;;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") "req");;
    clerk.Clerk__ApplyRo (struct.loadF Clerk "ck" "ck") (![slice.T byteT] "enc").

(* vsm.go *)
