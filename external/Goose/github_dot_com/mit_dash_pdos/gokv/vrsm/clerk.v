(* autogenerated from github.com/mit-pdos/gokv/vrsm/clerk *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.trusted__proph.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.configservice.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.e.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.replica.
From Goose Require github_dot_com.tchajed.goose.machine.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 1 second *)
Definition PreferenceRefreshTime : expr := #1000000000.

Definition Clerk := struct.decl [
  "confCk" :: ptrT;
  "replicaClerks" :: slice.T ptrT;
  "preferredReplica" :: uint64T;
  "lastPreferenceRefresh" :: uint64T
].

Definition makeClerks: val :=
  rec: "makeClerks" "servers" :=
    let: "clerks" := ref_zero (slice.T ptrT) in
    let: "$a0" := NewSlice ptrT (slice.len (![slice.T uint64T] "servers")) in
    "clerks" <-[slice.T ptrT] "$a0";;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (slice.len (![slice.T ptrT] "clerks"))); (λ: <>, Skip) := λ: <>,
      let: "$a0" := replica.MakeClerk (SliceGet uint64T (![slice.T uint64T] "servers") (![uint64T] "i")) in
      SliceSet ptrT (![slice.T ptrT] "clerks") (![uint64T] "i") "$a0";;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      #()).

Definition Make: val :=
  rec: "Make" "confHosts" :=
    let: "ck" := ref_zero ptrT in
    let: "$a0" := struct.alloc Clerk (zero_val (struct.t Clerk)) in
    "ck" <-[ptrT] "$a0";;
    let: "$a0" := configservice.MakeClerk (![slice.T uint64T] "confHosts") in
    struct.storeF Clerk "confCk" (![ptrT] "ck") "$a0";;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "config" := ref_zero (slice.T uint64T) in
      let: "$a0" := configservice.Clerk__GetConfig (struct.loadF Clerk "confCk" (![ptrT] "ck")) in
      "config" <-[slice.T uint64T] "$a0";;
      (if: (slice.len (![slice.T uint64T] "config")) = #0
      then Continue
      else
        let: "$a0" := makeClerks (![slice.T uint64T] "config") in
        struct.storeF Clerk "replicaClerks" (![ptrT] "ck") "$a0";;
        Break);;
      #()).

(* will retry forever *)
Definition Clerk__Apply: val :=
  rec: "Clerk__Apply" "ck" "op" :=
    let: "ret" := ref (zero_val (slice.T byteT)) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := ref (zero_val uint64T) in
      let: ("$a0", "$a1") := replica.Clerk__Apply (SliceGet ptrT (struct.loadF Clerk "replicaClerks" (![ptrT] "ck")) #0) (![slice.T byteT] "op") in
      "ret" <-[slice.T byteT] "$a1";;
      "err" <-[uint64T] "$a0";;
      (if: (![uint64T] "err") = e.None
      then Break
      else
        machine.Sleep (#100 * #1000000);;
        let: "config" := ref_zero (slice.T uint64T) in
        let: "$a0" := configservice.Clerk__GetConfig (struct.loadF Clerk "confCk" (![ptrT] "ck")) in
        "config" <-[slice.T uint64T] "$a0";;
        (if: (slice.len (![slice.T uint64T] "config")) > #0
        then
          let: "$a0" := makeClerks (![slice.T uint64T] "config") in
          struct.storeF Clerk "replicaClerks" (![ptrT] "ck") "$a0";;
          #()
        else #());;
        Continue);;
      #()).

Definition Clerk__maybeRefreshPreference: val :=
  rec: "Clerk__maybeRefreshPreference" "ck" :=
    let: <> := ref_zero uint64T in
    let: "now" := ref_zero uint64T in
    let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
    "$a1";;
    "now" <-[uint64T] "$a0";;
    (if: (![uint64T] "now") > ((struct.loadF Clerk "lastPreferenceRefresh" (![ptrT] "ck")) + PreferenceRefreshTime)
    then
      let: "$a0" := (machine.RandomUint64 #()) `rem` (slice.len (struct.loadF Clerk "replicaClerks" (![ptrT] "ck"))) in
      struct.storeF Clerk "preferredReplica" (![ptrT] "ck") "$a0";;
      let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
      "$a1";;
      struct.storeF Clerk "lastPreferenceRefresh" (![ptrT] "ck") "$a0";;
      #()
    else #());;
    #().

Definition Clerk__ApplyRo2: val :=
  rec: "Clerk__ApplyRo2" "ck" "op" :=
    let: "ret" := ref (zero_val (slice.T byteT)) in
    Clerk__maybeRefreshPreference (![ptrT] "ck");;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "offset" := ref_zero uint64T in
      let: "$a0" := struct.loadF Clerk "preferredReplica" (![ptrT] "ck") in
      "offset" <-[uint64T] "$a0";;
      let: "err" := ref (zero_val uint64T) in
      let: "i" := ref (zero_val uint64T) in
      (for: (λ: <>, (![uint64T] "i") < (slice.len (struct.loadF Clerk "replicaClerks" (![ptrT] "ck")))); (λ: <>, Skip) := λ: <>,
        let: "k" := ref_zero uint64T in
        let: "$a0" := ((![uint64T] "i") + (![uint64T] "offset")) `rem` (slice.len (struct.loadF Clerk "replicaClerks" (![ptrT] "ck"))) in
        "k" <-[uint64T] "$a0";;
        let: ("$a0", "$a1") := replica.Clerk__ApplyRo (SliceGet ptrT (struct.loadF Clerk "replicaClerks" (![ptrT] "ck")) (![uint64T] "k")) (![slice.T byteT] "op") in
        "ret" <-[slice.T byteT] "$a1";;
        "err" <-[uint64T] "$a0";;
        (if: (![uint64T] "err") = e.None
        then
          let: "$a0" := ![uint64T] "k" in
          struct.storeF Clerk "preferredReplica" (![ptrT] "ck") "$a0";;
          Break
        else #());;
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
        "$a1";;
        struct.storeF Clerk "lastPreferenceRefresh" (![ptrT] "ck") "$a0";;
        Continue)).

Definition Clerk__ApplyRo: val :=
  rec: "Clerk__ApplyRo" "ck" "op" :=
    let: "p" := ref_zero ProphIdT in
    let: "$a0" := trusted__proph.NewProph #() in
    "p" <-[ProphIdT] "$a0";;
    let: "v" := ref_zero (slice.T byteT) in
    let: "$a0" := Clerk__ApplyRo2 (![ptrT] "ck") (![slice.T byteT] "op") in
    "v" <-[slice.T byteT] "$a0";;
    trusted__proph.ResolveBytes (![ProphIdT] "p") (![slice.T byteT] "v");;
    return: (![slice.T byteT] "v").
