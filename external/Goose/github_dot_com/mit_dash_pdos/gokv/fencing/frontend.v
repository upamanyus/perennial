(* autogenerated from github.com/mit-pdos/gokv/fencing/frontend *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.fencing.config.
From Goose Require github_dot_com.mit_dash_pdos.gokv.fencing.ctr.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* client.go *)

Definition RPC_FAI : expr := #0.

Definition Clerk := struct.decl [
  "cl" :: ptrT
].

Definition Clerk__FetchAndIncrement: val :=
  rec: "Clerk__FetchAndIncrement" "ck" "key" "ret" :=
    let: "ret" := ref_to ptrT "ret" in
    let: "key" := ref_to uint64T "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "reply_ptr" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    "reply_ptr" <-[ptrT] "$a0";;
    let: "enc" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc #8 in
    "enc" <-[struct.t marshal.Enc] "$a0";;
    marshal.Enc__PutInt (![struct.t marshal.Enc] "enc") (![uint64T] "key");;
    let: "err" := ref_zero uint64T in
    let: "$a0" := urpc.Client__Call (struct.loadF Clerk "cl" (![ptrT] "ck")) RPC_FAI (marshal.Enc__Finish (![struct.t marshal.Enc] "enc")) (![ptrT] "reply_ptr") #100 in
    "err" <-[uint64T] "$a0";;
    (if: (![uint64T] "err") ≠ #0
    then return: (![uint64T] "err")
    else #());;
    let: "dec" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] (![ptrT] "reply_ptr")) in
    "dec" <-[struct.t marshal.Dec] "$a0";;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "dec") in
    (![ptrT] "ret") <-[uint64T] "$a0";;
    return: (#0).

Definition MakeClerk: val :=
  rec: "MakeClerk" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "ck" := ref_zero ptrT in
    let: "$a0" := struct.alloc Clerk (zero_val (struct.t Clerk)) in
    "ck" <-[ptrT] "$a0";;
    let: "$a0" := urpc.MakeClient (![uint64T] "host") in
    struct.storeF Clerk "cl" (![ptrT] "ck") "$a0";;
    return: (![ptrT] "ck").

(* server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "epoch" :: uint64T;
  "ck1" :: ptrT;
  "ck2" :: ptrT
].

(* pre: key == 0 or key == 1 *)
Definition Server__FetchAndIncrement: val :=
  rec: "Server__FetchAndIncrement" "s" "key" :=
    let: "key" := ref_to uint64T "key" in
    let: "s" := ref_to ptrT "s" in
    sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;
    let: "ret" := ref (zero_val uint64T) in
    (if: (![uint64T] "key") = #0
    then
      let: "$a0" := ctr.Clerk__Get (struct.loadF Server "ck1" (![ptrT] "s")) (struct.loadF Server "epoch" (![ptrT] "s")) in
      "ret" <-[uint64T] "$a0";;
      std.SumAssumeNoOverflow (![uint64T] "ret") #1;;
      ctr.Clerk__Put (struct.loadF Server "ck1" (![ptrT] "s")) ((![uint64T] "ret") + #1) (struct.loadF Server "epoch" (![ptrT] "s"));;
      #()
    else
      let: "$a0" := ctr.Clerk__Get (struct.loadF Server "ck2" (![ptrT] "s")) (struct.loadF Server "epoch" (![ptrT] "s")) in
      "ret" <-[uint64T] "$a0";;
      std.SumAssumeNoOverflow (![uint64T] "ret") #1;;
      ctr.Clerk__Put (struct.loadF Server "ck2" (![ptrT] "s")) ((![uint64T] "ret") + #1) (struct.loadF Server "epoch" (![ptrT] "s"));;
      #());;
    sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;
    return: (![uint64T] "ret").

Definition StartServer: val :=
  rec: "StartServer" "me" "configHost" "host1" "host2" :=
    let: "host2" := ref_to uint64T "host2" in
    let: "host1" := ref_to uint64T "host1" in
    let: "configHost" := ref_to uint64T "configHost" in
    let: "me" := ref_to uint64T "me" in
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc Server (zero_val (struct.t Server)) in
    "s" <-[ptrT] "$a0";;
    let: "configCk" := ref_zero ptrT in
    let: "$a0" := config.MakeClerk (![uint64T] "configHost") in
    "configCk" <-[ptrT] "$a0";;
    let: "$a0" := config.Clerk__AcquireEpoch (![ptrT] "configCk") (![uint64T] "me") in
    struct.storeF Server "epoch" (![ptrT] "s") "$a0";;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    struct.storeF Server "mu" (![ptrT] "s") "$a0";;
    let: "$a0" := ctr.MakeClerk (![uint64T] "host1") in
    struct.storeF Server "ck1" (![ptrT] "s") "$a0";;
    let: "$a0" := ctr.MakeClerk (![uint64T] "host2") in
    struct.storeF Server "ck2" (![ptrT] "s") "$a0";;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;
    let: "$a0" := (λ: "args" "reply",
      let: "dec" := ref_zero (struct.t marshal.Dec) in
      let: "$a0" := marshal.NewDec (![slice.T byteT] "args") in
      "dec" <-[struct.t marshal.Dec] "$a0";;
      let: "enc" := ref_zero (struct.t marshal.Enc) in
      let: "$a0" := marshal.NewEnc #8 in
      "enc" <-[struct.t marshal.Enc] "$a0";;
      marshal.Enc__PutInt (![struct.t marshal.Enc] "enc") (Server__FetchAndIncrement (![ptrT] "s") (marshal.Dec__GetInt (![struct.t marshal.Dec] "dec")));;
      let: "$a0" := marshal.Enc__Finish (![struct.t marshal.Enc] "enc") in
      (![ptrT] "reply") <-[slice.T byteT] "$a0";;
      #()
      ) in
    MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_FAI "$a0";;
    let: "r" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    "r" <-[ptrT] "$a0";;
    urpc.Server__Serve (![ptrT] "r") (![uint64T] "me");;
    #().
